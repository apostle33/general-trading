<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRADING SUITE | Programa 1 - Gesti√≥n de Trades</title>
    <style>
        /* ===== ESTILOS CYBERPUNK BASE ===== */
        :root {
            --bg-1: #06060a;
            --bg-2: #0b0011;
            --neon-cyan: #00f0ff;
            --neon-blue: #6f5cff;
            --neon-magenta: #ff4cff;
            --neon-green: #00ff88;
            --neon-red: #ff5555;
            --neon-yellow: #ffff00;
            --muted: rgba(230, 238, 248, 0.55);
            --card-bg: rgba(20, 20, 40, 0.85);
            --glow-cyan: 0 0 10px rgba(0, 240, 255, 0.5);
            --glow-green: 0 0 10px rgba(0, 255, 136, 0.5);
            --glow-red: 0 0 10px rgba(255, 85, 85, 0.5);
            --radius: 8px;
            --border-thin: 1px solid rgba(0, 240, 255, 0.2);
            font-family: 'Segoe UI', 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-1);
            color: #dfefff;
            min-height: 100vh;
            overflow-x: hidden;
            background-image: 
                linear-gradient(rgba(0, 240, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 240, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .app-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        /* ===== HEADER ===== */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            margin-bottom: 20px;
            border-bottom: var(--border-thin);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo h1 {
            font-size: 24px;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--glow-cyan);
            letter-spacing: 1px;
        }

        .program-indicator {
            background: rgba(0, 240, 255, 0.1);
            padding: 5px 15px;
            border-radius: var(--radius);
            border: var(--border-thin);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ===== LAYOUT PRINCIPAL ===== */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* ===== FORMULARIO DE TRADES ===== */
        .form-container {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 20px;
            border: var(--border-thin);
            backdrop-filter: blur(5px);
        }

        .form-title {
            color: var(--neon-cyan);
            font-size: 18px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: var(--border-thin);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        @media (max-width: 768px) {
            .form-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-label {
            font-size: 12px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input, .form-select, .form-textarea {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 4px;
            padding: 8px 12px;
            color: #dfefff;
            font-family: inherit;
            transition: all 0.3s;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--neon-cyan);
            box-shadow: var(--glow-cyan);
        }

        .form-textarea {
            grid-column: 1 / -1;
            min-height: 80px;
            resize: vertical;
        }

        /* Botones del formulario */
        .form-actions {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: var(--border-thin);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-blue));
            color: #000;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--neon-cyan);
            border: 1px solid rgba(0, 240, 255, 0.3);
        }

        .btn-danger {
            background: rgba(255, 85, 85, 0.1);
            color: var(--neon-red);
            border: 1px solid rgba(255, 85, 85, 0.3);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        /* ===== TABLA DE TRADES ===== */
        .table-container {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 20px;
            border: var(--border-thin);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: var(--border-thin);
        }

        @media (max-width: 768px) {
            .table-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
        }

        .table-title {
            color: var(--neon-cyan);
            font-size: 18px;
        }

        .table-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        @media (max-width: 768px) {
            .table-controls {
                flex-direction: column;
                gap: 10px;
            }
        }

        .search-box {
            background: rgba(0, 0, 0, 0.3);
            border: var(--border-thin);
            border-radius: 4px;
            padding: 6px 12px;
            color: #dfefff;
            width: 200px;
        }

        @media (max-width: 768px) {
            .search-box {
                width: 100%;
            }
        }

        .filter-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 4px 8px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 4px;
            color: var(--muted);
            cursor: pointer;
            transition: all 0.3s;
        }

        .filter-btn.active {
            background: rgba(0, 240, 255, 0.1);
            color: var(--neon-cyan);
            border-color: var(--neon-cyan);
        }

        /* Tabla principal */
        .trades-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
            flex: 1;
            min-height: 300px;
        }

        .trades-table th {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            text-align: left;
            font-weight: 600;
            color: var(--neon-cyan);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: var(--border-thin);
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .trades-table th:hover {
            background: rgba(0, 240, 255, 0.1);
        }

        .trades-table th.sort-asc::after {
            content: " ‚Üë";
            color: var(--neon-green);
        }

        .trades-table th.sort-desc::after {
            content: " ‚Üì";
            color: var(--neon-red);
        }

        .trades-table td {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(0, 240, 255, 0.05);
            font-size: 13px;
        }

        .trades-table tr:hover {
            background: rgba(0, 240, 255, 0.05);
        }

        /* Colores condicionales */
        .pnl-positive {
            color: var(--neon-green);
            font-weight: 600;
        }

        .pnl-negative {
            color: var(--neon-red);
            font-weight: 600;
        }

        .direction-buy {
            color: var(--neon-green);
        }

        .direction-sell {
            color: var(--neon-red);
        }

        /* Acciones de la tabla */
        .action-buttons {
            display: flex;
            gap: 5px;
        }

        .action-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            background: transparent;
            color: var(--muted);
        }

        .action-btn:hover {
            transform: scale(1.1);
        }

        .edit-btn:hover {
            color: var(--neon-cyan);
            background: rgba(0, 240, 255, 0.1);
        }

        .delete-btn:hover {
            color: var(--neon-red);
            background: rgba(255, 85, 85, 0.1);
        }

        .duplicate-btn:hover {
            color: var(--neon-yellow);
            background: rgba(255, 255, 0, 0.1);
        }

        /* ===== PANEL INFERIOR ===== */
        .bottom-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .bottom-panel {
                grid-template-columns: 1fr;
            }
        }

        /* Estad√≠sticas */
        .stats-container {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 15px;
            border: var(--border-thin);
            backdrop-filter: blur(5px);
        }

        .stats-title {
            color: var(--neon-cyan);
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .stat-label {
            font-size: 11px;
            color: var(--muted);
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--neon-green);
        }

        .stat-value.negative {
            color: var(--neon-red);
        }

        /* Importaci√≥n/Exportaci√≥n */
        .io-container {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 15px;
            border: var(--border-thin);
            backdrop-filter: blur(5px);
        }

        .io-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .io-btn {
            flex: 1;
            min-width: 120px;
        }

        .file-input {
            display: none;
        }

        /* ===== PAGINACI√ìN ===== */
        .pagination-container {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .pagination-btn {
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 4px;
            color: var(--muted);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
            min-width: 30px;
        }

        .pagination-btn:hover:not(:disabled) {
            background: rgba(0, 240, 255, 0.1);
            color: var(--neon-cyan);
            border-color: var(--neon-cyan);
        }

        .pagination-btn.active {
            background: rgba(0, 240, 255, 0.2);
            color: var(--neon-cyan);
            border-color: var(--neon-cyan);
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ===== UTILITIES ===== */
        .hidden {
            display: none !important;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        /* Modal de recuperaci√≥n */
        .recovery-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .recovery-content {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 30px;
            border: 2px solid var(--neon-red);
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 30px rgba(255, 85, 85, 0.3);
        }

        .recovery-title {
            color: var(--neon-red);
            font-size: 20px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .recovery-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        /* Backup Manager Modal */
        .backup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .backup-content {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 25px;
            border: 2px solid var(--neon-cyan);
            max-width: 700px;
            width: 95%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.3);
        }

        .backup-list {
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 4px;
            padding: 10px;
        }

        .backup-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(0, 240, 255, 0.1);
        }

        .backup-item:hover {
            background: rgba(0, 240, 255, 0.1);
        }

        /* ===== ESTILOS PARA PANEL DE TRADES INV√ÅLIDOS ===== */
        .invalid-trades-panel {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 20px;
            border: 2px solid var(--neon-yellow);
            margin-top: 20px;
            backdrop-filter: blur(5px);
        }

        .invalid-trades-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: var(--border-thin);
        }

        .invalid-trades-title {
            color: var(--neon-yellow);
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .invalid-trades-count {
            background: rgba(255, 255, 0, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
        }

        .invalid-trades-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 0, 0.2);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.3);
        }

        .invalid-trade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 0, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 0, 0.1);
            transition: all 0.3s;
        }

        .invalid-trade-item:hover {
            background: rgba(255, 255, 0, 0.1);
            transform: translateX(2px);
        }

        .invalid-trade-info {
            flex: 1;
        }

        .invalid-trade-reason {
            font-size: 11px;
            color: var(--neon-red);
            margin-top: 3px;
            font-style: italic;
        }

        .invalid-trade-actions {
            display: flex;
            gap: 5px;
        }

        .selected-invalid {
            background: rgba(0, 240, 255, 0.1) !important;
            border-color: var(--neon-cyan) !important;
        }

        .invalid-trade-checkbox {
            margin-right: 8px;
            cursor: pointer;
        }

        /* Bot√≥n para mostrar trades inv√°lidos */
        .show-invalid-trades-btn {
            position: relative;
            background: rgba(255, 255, 0, 0.1);
            color: var(--neon-yellow);
            border: 1px solid rgba(255, 255, 0, 0.3);
        }

        .show-invalid-trades-btn:hover {
            background: rgba(255, 255, 0, 0.2);
        }

        .show-invalid-trades-btn .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--neon-red);
            color: #000;
            font-size: 10px;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Pesta√±as para clasificar trades inv√°lidos */
        .invalid-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 0, 0.2);
            padding-bottom: 10px;
        }

        .invalid-tab {
            padding: 5px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 0, 0.2);
            border-radius: 4px;
            color: var(--muted);
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
        }

        .invalid-tab:hover {
            background: rgba(255, 255, 0, 0.1);
        }

        .invalid-tab.active {
            background: rgba(255, 255, 0, 0.2);
            color: var(--neon-yellow);
            border-color: var(--neon-yellow);
        }

        /* Scrollbar personalizada */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--neon-cyan), var(--neon-magenta));
            border-radius: 3px;
        }

        /* Notificaciones */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 6px;
            font-weight: 600;
            z-index: 10002;
            animation: slideIn 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 400px;
            word-wrap: break-word;
        }

        .notification.success {
            background: rgba(0, 255, 136, 0.9);
            color: #000;
        }

        .notification.error {
            background: rgba(255, 85, 85, 0.9);
            color: #000;
        }

        .notification.warning {
            background: rgba(255, 255, 0, 0.9);
            color: #000;
        }

        .notification.info {
            background: rgba(0, 240, 255, 0.9);
            color: #000;
        }

        /* Animaciones */
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Spinner de carga */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--neon-cyan);
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Modal de recuperaci√≥n -->
    <div id="recoveryModal" class="recovery-modal hidden">
        <div class="recovery-content">
            <div class="recovery-title">
                <span>‚ö†Ô∏è</span> DATOS CORRUPTOS DETECTADOS
            </div>
            <p style="margin-bottom: 15px; color: var(--muted);">
                Se detectaron datos corruptos en el almacenamiento local. Esto puede causar que la aplicaci√≥n se congele o funcione incorrectamente.
            </p>
            <p style="margin-bottom: 20px; font-size: 14px; color: var(--neon-yellow);">
                <strong>Causas posibles:</strong> Archivos importados inv√°lidos, datos malformados, o corrupci√≥n del navegador.
            </p>
            <div class="recovery-buttons">
                <button id="repairDataBtn" class="btn btn-primary">
                    <span class="spinner hidden"></span>
                    <span>üîß Reparar Datos</span>
                </button>
                <button id="resetDataBtn" class="btn btn-danger">
                    üóëÔ∏è Resetear Todo
                </button>
                <button id="ignoreBtn" class="btn btn-secondary">
                    ‚è≠Ô∏è Ignorar
                </button>
            </div>
        </div>
    </div>

    <!-- Modal de gesti√≥n de backups -->
    <div id="backupModal" class="backup-modal hidden">
        <div class="backup-content">
            <div class="recovery-title">
                <span>üíæ</span> GESTOR DE BACKUPS
            </div>
            <p style="margin-bottom: 15px; color: var(--muted);">
                Aqu√≠ puedes gestionar los backups autom√°ticos. Se mantienen hasta 10 backups.
            </p>
            
            <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                <button id="createBackupBtn" class="btn btn-primary">
                    üìÅ Crear Backup Ahora
                </button>
                <button id="restoreLatestBtn" class="btn btn-secondary">
                    ‚Ü©Ô∏è Restaurar √öltimo
                </button>
                <button id="closeBackupModal" class="btn btn-secondary">
                    ‚úñÔ∏è Cerrar
                </button>
            </div>
            
            <div style="margin-bottom: 10px; font-size: 12px; color: var(--neon-cyan);">
                üìä Backups disponibles (<span id="backupCount">0</span>)
            </div>
            
            <div class="backup-list" id="backupList">
                <!-- Lista de backups din√°mica -->
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                <div style="font-size: 11px; color: var(--muted);">
                    <strong>‚ÑπÔ∏è Informaci√≥n:</strong> Los backups se crean autom√°ticamente cada 5 minutos y antes de operaciones cr√≠ticas.
                </div>
            </div>
        </div>
    </div>

    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <div style="width: 40px; height: 40px; border-radius: 6px; background: linear-gradient(45deg, var(--neon-cyan), var(--neon-magenta));"></div>
                <div>
                    <h1>TRADING SUITE</h1>
                    <div style="font-size: 12px; color: var(--muted);">Professional Trading Analytics</div>
                </div>
            </div>
            <div class="program-indicator">
                PROGRAMA 1: <strong style="color: var(--neon-cyan);">Gesti√≥n de Trades</strong>
                <button id="showInvalidTradesBtn" class="debug-btn show-invalid-trades-btn">
                    ‚ö†Ô∏è Trades Invalidos
                    <span class="notification-badge hidden" id="invalidTradesCount">0</span>
                </button>
                <button id="dataManagerBtn" class="debug-btn">
                    üõ†Ô∏è Gestor de Datos
                </button>
                <button id="backupManagerBtn" class="debug-btn">
                    üíæ Gestor de Backups
                </button>
                <button id="debugBtn" class="debug-btn">
                    üêõ Debug
                </button>
            </div>
        </div>

        <!-- Contenido Principal -->
        <div class="main-content">
            <!-- Formulario de Entrada -->
            <div class="form-container">
                <div class="form-title">
                    <span>üìù NUEVO TRADE</span>
                    <span id="formModeIndicator" style="font-size: 12px; color: var(--neon-yellow);">Modo: Creaci√≥n</span>
                </div>
                
                <div class="form-grid">
                    <!-- Fechas -->
                    <div class="form-group">
                        <label class="form-label">Fecha Entrada</label>
                        <input type="datetime-local" class="form-input" id="entryDate">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Fecha Salida</label>
                        <input type="datetime-local" class="form-input" id="exitDate">
                    </div>

                    <!-- Instrumento y Setup -->
                    <div class="form-group">
                        <label class="form-label">Instrumento</label>
                        <input type="text" class="form-input" id="instrument" placeholder="EURUSD, BTCUSD, etc." list="instrumentList">
                        <datalist id="instrumentList"></datalist>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Setup / Estrategia</label>
                        <input type="text" class="form-input" id="strategy" placeholder="Scalping, Swing, etc.">
                    </div>

                    <!-- Temporalidad y Direcci√≥n -->
                    <div class="form-group">
                        <label class="form-label">Temporalidad</label>
                        <select class="form-select" id="timeframe">
                            <option value="">Seleccionar</option>
                            <option value="M1">M1</option>
                            <option value="M5">M5</option>
                            <option value="M15">M15</option>
                            <option value="M30">M30</option>
                            <option value="H1">H1</option>
                            <option value="H4">H4</option>
                            <option value="D1">D1</option>
                            <option value="W1">W1</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Direcci√≥n</label>
                        <select class="form-select" id="direction">
                            <option value="">Seleccionar</option>
                            <option value="buy">BUY</option>
                            <option value="sell">SELL</option>
                        </select>
                    </div>

                    <!-- Precios -->
                    <div class="form-group">
                        <label class="form-label">Precio Entrada</label>
                        <input type="number" step="0.00001" class="form-input" id="entryPrice" placeholder="1.09500">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Precio Salida</label>
                        <input type="number" step="0.00001" class="form-input" id="exitPrice" placeholder="1.09600">
                    </div>

                    <!-- SL y TP -->
                    <div class="form-group">
                        <label class="form-label">Stop Loss</label>
                        <input type="number" step="0.00001" class="form-input" id="sl" placeholder="1.09400">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Take Profit</label>
                        <input type="number" step="0.00001" class="form-input" id="tp" placeholder="1.09700">
                    </div>

                    <!-- Tama√±o y Comisi√≥n -->
                    <div class="form-group">
                        <label class="form-label">Tama√±o (Lotes/Unidades)</label>
                        <input type="number" step="0.01" class="form-input" id="size" placeholder="1.00" value="1.00">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Comisi√≥n ($)</label>
                        <input type="number" step="0.01" class="form-input" id="commission" placeholder="2.50" value="0.00">
                    </div>

                    <!-- PnL Calculados -->
                    <div class="form-group">
                        <label class="form-label">PnL ($)</label>
                        <input type="number" step="0.01" class="form-input" id="pnl" placeholder="Auto-calculado" readonly>
                    </div>
                    <div class="form-group">
                        <label class="form-label">PnL (R)</label>
                        <input type="number" step="0.01" class="form-input" id="pnlR" placeholder="Auto-calculado" readonly>
                    </div>

                    <!-- Comentarios -->
                    <div class="form-group" style="grid-column: 1 / -1;">
                        <label class="form-label">Comentarios</label>
                        <textarea class="form-textarea" id="comments" rows="3" placeholder="Notas sobre el trade..."></textarea>
                    </div>

                    <!-- Botones de Acci√≥n -->
                    <div class="form-actions">
                        <button class="btn btn-primary" id="addTradeBtn">
                            <span>‚ûï</span> Agregar Trade
                        </button>
                        <button class="btn btn-secondary" id="updateTradeBtn" style="display: none;">
                            <span>üíæ</span> Actualizar Trade
                        </button>
                        <button class="btn btn-secondary" id="resetFormBtn">
                            <span>üîÑ</span> Resetear
                        </button>
                        <button class="btn btn-secondary" id="cancelEditBtn" style="display: none;">
                            <span>‚ùå</span> Cancelar
                        </button>
                    </div>
                </div>
            </div>

            <!-- Tabla de Trades -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">üìä TRADES REGISTRADOS</div>
                    <div class="table-controls">
                        <input type="text" class="search-box" id="searchInput" placeholder="Buscar trades...">
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-filter="all">Todos</button>
                            <button class="filter-btn" data-filter="win">Ganadores</button>
                            <button class="filter-btn" data-filter="loss">Perdedores</button>
                            <button class="filter-btn" data-filter="buy">BUY</button>
                            <button class="filter-btn" data-filter="sell">SELL</button>
                        </div>
                    </div>
                </div>

                <table class="trades-table" id="tradesTable">
                    <thead>
                        <tr>
                            <th data-sort="entryDate">Fecha Entrada</th>
                            <th data-sort="instrument">Instrumento</th>
                            <th data-sort="direction">Dir</th>
                            <th data-sort="pnl">PnL ($)</th>
                            <th data-sort="pnlR">PnL (R)</th>
                            <th data-sort="strategy">Setup</th>
                            <th>Acciones</th>
                        </tr>
                    </thead>
                    <tbody id="tradesTableBody">
                        <!-- Trades cargados din√°micamente -->
                        <tr id="noTradesRow">
                            <td colspan="7" style="text-align: center; padding: 40px; color: var(--muted);">
                                No hay trades registrados. Agrega tu primer trade usando el formulario.
                            </td>
                        </tr>
                    </tbody>
                </table>

                <!-- Controles de Paginaci√≥n -->
                <div id="paginationControls" class="pagination-container">
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <div style="font-size: 12px; color: var(--muted);" id="tradeCount">
                        Mostrando 0 trades
                    </div>
                    <div class="action-buttons">
                        <button class="btn btn-secondary" id="selectAllBtn" style="font-size: 12px; padding: 4px 8px;">
                            <span>‚úì</span> Seleccionar Todos
                        </button>
                        <button class="btn btn-danger" id="deleteSelectedBtn" style="font-size: 12px; padding: 4px 8px; display: none;">
                            <span>üóë</span> Eliminar Seleccionados (<span id="selectedCount">0</span>)
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== PANEL DE TRADES INV√ÅLIDOS/DUPLICADOS ===== -->
        <div id="invalidTradesPanel" class="invalid-trades-panel hidden">
            <div class="invalid-trades-header">
                <div class="invalid-trades-title">
                    ‚ö†Ô∏è TRADES PROBLEM√ÅTICOS
                    <span class="invalid-trades-count" id="panelInvalidCount">0</span>
                </div>
                <button id="closeInvalidPanel" class="btn btn-secondary" style="padding: 4px 12px; font-size: 12px;">
                    ‚úñÔ∏è Cerrar
                </button>
            </div>
            
            <!-- Pesta√±as para clasificar -->
            <div class="invalid-tabs">
                <button class="invalid-tab active" data-tab="all">Todos (<span id="tabAllCount">0</span>)</button>
                <button class="invalid-tab" data-tab="duplicates">Duplicados (<span id="tabDuplicatesCount">0</span>)</button>
                <button class="invalid-tab" data-tab="invalid">Inv√°lidos (<span id="tabInvalidCount">0</span>)</button>
                <button class="invalid-tab" data-tab="breakeven">Breakeven (<span id="tabBreakevenCount">0</span>)</button>
            </div>
            
            <div class="invalid-trades-list" id="invalidTradesList">
                <!-- Lista din√°mica de trades inv√°lidos -->
            </div>
            
            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button id="restoreSelectedInvalidBtn" class="btn btn-primary" style="flex: 1;">
                    ‚Ü©Ô∏è Restaurar Seleccionados
                </button>
                <button id="repairSelectedInvalidBtn" class="btn btn-secondary" style="flex: 1;">
                    üîß Reparar Seleccionados
                </button>
                <button id="deleteSelectedInvalidBtn" class="btn btn-danger" style="flex: 1;">
                    üóëÔ∏è Eliminar Seleccionados
                </button>
            </div>
            
            <div style="margin-top: 10px; display: flex; gap: 10px;">
                <button id="markAllValidBtn" class="btn btn-secondary" style="flex: 1; font-size: 12px;">
                    ‚úÖ Marcar Todos como V√°lidos
                </button>
                <button id="exportInvalidBtn" class="btn btn-secondary" style="flex: 1; font-size: 12px;">
                    üì• Exportar Lista
                </button>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">
                <div style="font-size: 11px; color: var(--neon-yellow);">
                    ‚ÑπÔ∏è Este panel muestra trades que el sistema ha detectado como problem√°ticos.
                    <strong>Restaurar</strong> mueve el trade a la lista principal, <strong>Reparar</strong> intenta corregir problemas autom√°ticamente.
                </div>
            </div>
        </div>

        <!-- Panel Inferior -->
        <div class="bottom-panel">
            <!-- Estad√≠sticas R√°pidas -->
            <div class="stats-container">
                <div class="stats-title">
                    <span>üìà ESTAD√çSTICAS R√ÅPIDAS</span>
                    <span id="statsUpdateTime" style="font-size: 11px; color: var(--muted);">Actualizado: --:--</span>
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Total Trades</div>
                        <div class="stat-value" id="statTotalTrades">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value" id="statWinRate">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Profit Factor</div>
                        <div class="stat-value" id="statProfitFactor">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Expectancy (R)</div>
                        <div class="stat-value" id="statExpectancy">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Mejor Trade (R)</div>
                        <div class="stat-value" id="statBestTrade">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Peor Trade (R)</div>
                        <div class="stat-value negative" id="statWorstTrade">0.00</div>
                    </div>
                </div>
            </div>

            <!-- Importaci√≥n/Exportaci√≥n -->
            <div class="io-container">
                <div class="stats-title">üíæ IMPORTAR / EXPORTAR DATOS</div>
                <div style="font-size: 12px; color: var(--muted); margin-bottom: 10px;">
                    Intercambia datos con otros programas del Trading Suite
                </div>
                <div class="io-buttons">
                    <button class="btn btn-primary io-btn" id="exportCsvBtn">
                        <span>üì•</span> Exportar CSV
                    </button>
                    <button class="btn btn-primary io-btn" id="exportJsonBtn">
                        <span>üì•</span> Exportar JSON
                    </button>
                    <label for="importJsonInput" class="btn btn-secondary io-btn" style="cursor: pointer;">
                        <span>üì§</span> Importar JSON
                        <input type="file" id="importJsonInput" class="file-input" accept=".json">
                    </label>
                    <label for="importCsvInput" class="btn btn-secondary io-btn" style="cursor: pointer;">
                        <span>üì§</span> Importar CSV
                        <input type="file" id="importCsvInput" class="file-input" accept=".csv">
                    </label>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">
                    <div style="font-size: 11px; color: var(--neon-cyan); margin-bottom: 5px;">üîó Compatibilidad:</div>
                    <div style="font-size: 10px; color: var(--muted);">
                        ‚Ä¢ Programa 2 (M√©tricas B√°sicas) ‚Ä¢ Programa 3 (M√©tricas Avanzadas)<br>
                        ‚Ä¢ Programa 4 (Gr√°ficas) ‚Ä¢ Programa 9 (Exportador de Reportes)
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURACI√ìN Y CONSTANTES =====
        const TRADE_STORAGE_KEY = 'trading_suite_trades_v3';
        const BACKUP_KEY = 'trading_suite_backup_latest';
        const ACTION_LOG_KEY = 'trading_suite_action_log';
        const INVALID_TRADES_KEY = 'trading_suite_invalid_trades'; // Nueva clave para trades inv√°lidos
        
        // Configuraci√≥n de backups
        const BACKUP_CONFIG = {
            prefix: 'trading_suite_backup_',
            maxBackups: 10,
            autoSaveInterval: 300000, // 5 minutos
            maxLogEntries: 1000
        };

        // Instrumentos y estrategias comunes
        const INSTRUMENTS = ['EURUSD', 'GBPUSD', 'USDJPY', 'XAUUSD', 'BTCUSDT', 'ETHUSDT', 'SPX', 'NAS100'];
        const STRATEGIES = ['Scalping', 'Day Trading', 'Swing Trading', 'Position Trading', 'Arbitrage', 'Grid'];
        const TIMEFRAMES = ['M1', 'M5', 'M15', 'M30', 'H1', 'H4', 'D1', 'W1', 'MN1'];

        // ===== SCHEMA ACTUALIZADO PARA COMPATIBILIDAD CON SIMULADOR =====
        const TRADE_SCHEMA = {
            version: '3.0',
            required: ['id', 'instrument', 'direction', 'entryPrice', 'exitPrice'],
            optional: ['strategy', 'timeframe', 'session', 'sl', 'tp', 'size', 
                      'commission', 'pnl', 'pnlR', 'resultR', 'outcome', 'comments',
                      'entryDate', 'exitDate', '_version', '_created', '_modified', 
                      '_checksum', '_sourceVersion', '_source', '_originalId'],
            types: {
                id: 'string',
                instrument: 'string',
                direction: ['buy', 'sell'],
                entryPrice: 'number',
                exitPrice: 'number',
                size: 'number',
                commission: 'number',
                pnl: 'number',
                pnlR: 'number',
                resultR: 'number',
                outcome: ['win', 'loss', 'breakeven', null],
                session: 'string',
                strategy: 'string',
                timeframe: 'string',
                comments: 'string'
            },
            defaults: {
                strategy: '',
                timeframe: '',
                session: '',
                sl: 0,
                tp: 0,
                size: 1,
                commission: 0,
                comments: '',
                pnl: 0,
                pnlR: 0,
                resultR: 0,
                outcome: null
            }
        };

        // ===== ESTADO DE LA APLICACI√ìN =====
        let trades = [];
        let invalidTrades = [];
        let selectedInvalidTrades = new Set();
        let currentEditId = null;
        let currentSort = { column: 'entryDate', direction: 'desc' };
        let currentFilter = 'all';
        let selectedTrades = new Set();
        let isSafeMode = false;
        let currentPage = 1;
        const TRADES_PER_PAGE = 20;
        let autoSaveTimer = null;
        let hasUnsavedChanges = false;
        let searchTimeout = null;
        let currentInvalidTab = 'all'; // 'all', 'duplicates', 'invalid', 'breakeven'
        let importSessionId = null; // Para evitar duplicados en la misma sesi√≥n de importaci√≥n

        // ===== FUNCIONES DE UTILIDAD MEJORADAS =====
        function generateId() {
            return 'trade_' + Date.now() + '_' + 
                   Math.random().toString(36).substr(2, 9) + '_' + 
                   performance.now().toString(36).replace('.', '');
        }

        function generateImportSessionId() {
            importSessionId = 'import_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            return importSessionId;
        }

        function showNotification(message, type = 'info', duration = 3000) {
            try {
                // Eliminar notificaciones anteriores
                const existingNotifications = document.querySelectorAll('.notification');
                existingNotifications.forEach(n => n.remove());
                
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.style.animation = 'slideOut 0.3s ease';
                        setTimeout(() => notification.remove(), 300);
                    }
                }, duration);
            } catch (e) {
                console.error('Error mostrando notificaci√≥n:', e);
            }
        }

        function showLoading(button, show = true) {
            if (!button) return;
            const spinner = button.querySelector('.spinner');
            const text = button.querySelector('span:not(.spinner)');
            
            if (spinner) {
                spinner.classList.toggle('hidden', !show);
            }
            
            if (text) {
                text.style.opacity = show ? '0.5' : '1';
            }
            
            button.disabled = show;
        }

        // ===== CORRECCI√ìN: PERMITIR BREAKEVEN EN FORMULARIO =====
        function setupBreakevenValidation() {
            const entryPriceInput = document.getElementById('entryPrice');
            const exitPriceInput = document.getElementById('exitPrice');
            
            function validateBreakeven() {
                const entryPrice = parseFloat(entryPriceInput.value) || 0;
                const exitPrice = parseFloat(exitPriceInput.value) || 0;
                
                // Permitir breakeven (precios iguales)
                if (entryPrice && exitPrice && entryPrice === exitPrice) {
                    // Calcular PnL autom√°ticamente como 0 (solo comisiones)
                    const size = parseFloat(document.getElementById('size').value) || 1;
                    const commission = parseFloat(document.getElementById('commission').value) || 0;
                    const direction = document.getElementById('direction').value;
                    
                    // PnL = -comisi√≥n (solo se paga comisi√≥n en breakeven)
                    const pnl = -commission;
                    document.getElementById('pnl').value = pnl.toFixed(2);
                    document.getElementById('pnlR').value = '0.00';
                    
                    // Mostrar mensaje informativo
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: absolute;
                        background: rgba(255, 255, 0, 0.2);
                        border: 1px solid var(--neon-yellow);
                        padding: 5px 10px;
                        border-radius: 4px;
                        font-size: 11px;
                        color: var(--neon-yellow);
                        margin-top: 5px;
                        z-index: 1000;
                    `;
                    notification.textContent = '‚úì Trade en breakeven permitido (PnL = -comisi√≥n)';
                    
                    // Eliminar notificaciones anteriores
                    const oldNotification = document.querySelector('.breakeven-notification');
                    if (oldNotification) oldNotification.remove();
                    
                    notification.className = 'breakeven-notification';
                    exitPriceInput.parentNode.appendChild(notification);
                    
                    // Remover despu√©s de 3 segundos
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 3000);
                    
                    return true; // Permitir breakeven
                } else {
                    // Remover notificaci√≥n si existe
                    const notification = document.querySelector('.breakeven-notification');
                    if (notification) notification.remove();
                    
                    // Recalcular PnL normal
                    updateCalculatedFields();
                }
                
                return true;
            }
            
            entryPriceInput.addEventListener('input', validateBreakeven);
            exitPriceInput.addEventListener('input', validateBreakeven);
        }

        // ===== MEJORA 1: C√ÅLCULO DE PNL CORREGIDO =====
        function calculatePnl(entry, exit, size, direction, commission = 0, instrument = '') {
            if (!entry || !exit || !size || !direction) return 0;
            
            try {
                // Asegurar que sean n√∫meros
                entry = parseFloat(entry);
                exit = parseFloat(exit);
                size = parseFloat(size);
                commission = parseFloat(commission) || 0;
                
                // Si es breakeven (precios iguales), solo devolver -comisi√≥n
                if (entry === exit) {
                    return -commission;
                }
                
                // Diferencia de precio
                const priceDiff = exit - entry;
                
                // Determinar si es Forex o Crypto
                const isForex = /^(EUR|GBP|USD|JPY|AUD|NZD|CHF|CAD)[A-Z]{3}$/i.test(instrument || '');
                const isCrypto = /^(BTC|ETH|XRP|LTC|ADA)/i.test(instrument || '') || 
                                /USDT$/i.test(instrument || '') || 
                                /USD$/i.test(instrument || '');
                
                let pnl;
                
                if (isForex) {
                    // FOREX: PnL = (Precio Salida - Precio Entrada) √ó Lotes √ó 100,000
                    // 1 lote est√°ndar = 100,000 unidades
                    pnl = priceDiff * size * 100000;
                } else {
                    // CRYPTO/ACCIONES: PnL = (Precio Salida - Precio Entrada) √ó Cantidad
                    pnl = priceDiff * size;
                }
                
                // Aplicar direcci√≥n
                if (direction === 'sell') {
                    pnl = -pnl;
                }
                
                // Restar comisi√≥n
                pnl -= commission;
                
                return parseFloat(pnl.toFixed(2));
            } catch (e) {
                console.error('Error en calculatePnl:', e);
                return 0;
            }
        }

        function calculatePnlR(entry, exit, sl, direction) {
            try {
                if (!entry || !exit || !sl || sl === 0 || entry === sl) return 0;
                
                const risk = Math.abs(entry - sl);
                if (risk === 0) return 0;
                
                const reward = Math.abs(exit - entry);
                let rMultiple;
                
                if (direction === 'buy') {
                    rMultiple = (exit > entry ? 1 : -1) * (reward / risk);
                } else {
                    rMultiple = (exit < entry ? 1 : -1) * (reward / risk);
                }
                
                // Limitar valores extremos
                if (Math.abs(rMultiple) > 100) {
                    return rMultiple > 0 ? 100 : -100;
                }
                
                return parseFloat(rMultiple.toFixed(2));
            } catch (e) {
                console.error('Error calculando PnL(R):', e);
                return 0;
            }
        }

        // ===== MEJORA 2: FORMATO DE FECHAS CONSISTENTE =====
        function formatDateISO(dateString) {
            try {
                if (!dateString) return new Date().toISOString();
                
                // Si ya tiene formato ISO con Z, mantenerlo
                if (dateString.endsWith('Z') && dateString.includes('T')) {
                    return dateString;
                }
                
                // Si tiene formato YYYY-MM-DDTHH:MM
                if (dateString.includes('T') && dateString.length === 16) {
                    return new Date(dateString + ':00.000Z').toISOString();
                }
                
                // Si tiene formato YYYY-MM-DD HH:MM
                if (dateString.includes(' ') && dateString.length >= 16) {
                    const [datePart, timePart] = dateString.split(' ');
                    const formatted = datePart + 'T' + timePart + ':00.000Z';
                    return new Date(formatted).toISOString();
                }
                
                // Intento general
                const date = new Date(dateString);
                if (!isNaN(date.getTime())) {
                    return date.toISOString();
                }
                
                return new Date().toISOString();
            } catch (e) {
                console.error('Error formateando fecha:', e, dateString);
                return new Date().toISOString();
            }
        }

        function formatDateForInput(dateString) {
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) {
                    return new Date().toISOString().slice(0, 16);
                }
                return date.toISOString().slice(0, 16);
            } catch (e) {
                return new Date().toISOString().slice(0, 16);
            }
        }

        function formatDateForDisplay(dateString) {
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'Fecha inv√°lida';
                
                return date.toLocaleDateString('es-ES', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return 'Fecha inv√°lida';
            }
        }

        // ===== MEJORA 3: VALIDACI√ìN Y SANITIZACI√ìN MEJORADA =====
        function validateTradeSchema(trade) {
            try {
                // Validar que sea un objeto
                if (!trade || typeof trade !== 'object') {
                    return { valid: false, error: 'No es un objeto v√°lido' };
                }
                
                // Validar campos requeridos
                for (const field of TRADE_SCHEMA.required) {
                    if (trade[field] === undefined || trade[field] === null || trade[field] === '') {
                        return { valid: false, error: `Campo requerido faltante: ${field}` };
                    }
                }
                
                // Validar tipos
                for (const [field, expectedType] of Object.entries(TRADE_SCHEMA.types)) {
                    if (trade[field] !== undefined && trade[field] !== null && trade[field] !== '') {
                        if (Array.isArray(expectedType)) {
                            // Validar valores enumerados
                            if (!expectedType.includes(trade[field])) {
                                return { 
                                    valid: false, 
                                    error: `${field} debe ser uno de: ${expectedType.join(', ')}. Valor actual: ${trade[field]}` 
                                };
                            }
                        } else {
                            // Validar tipo b√°sico
                            const actualType = typeof trade[field];
                            if (actualType !== expectedType) {
                                // Permitir conversi√≥n de string a number para algunos campos
                                if (expectedType === 'number' && !isNaN(parseFloat(trade[field]))) {
                                    trade[field] = parseFloat(trade[field]);
                                } else {
                                    return { 
                                        valid: false, 
                                        error: `${field} debe ser ${expectedType}, pero es ${actualType}` 
                                    };
                                }
                            }
                        }
                    }
                }
                
                // Validar que exitDate > entryDate
                if (trade.entryDate && trade.exitDate) {
                    const entry = new Date(trade.entryDate);
                    const exit = new Date(trade.exitDate);
                    if (!isNaN(entry.getTime()) && !isNaN(exit.getTime()) && exit < entry) {
                        return { valid: false, error: 'exitDate no puede ser anterior a entryDate' };
                    }
                }
                
                // PERMITIR BREAKEVEN - No validar que entryPrice != exitPrice
                // Los trades en breakeven son v√°lidos
                
                return { valid: true };
            } catch (e) {
                return { valid: false, error: `Error de validaci√≥n: ${e.message}` };
            }
        }

        function sanitizeTrade(trade) {
            try {
                if (!trade || typeof trade !== 'object') {
                    trade = {};
                }
                
                // Crear objeto sanitizado con defaults
                const sanitized = { ...TRADE_SCHEMA.defaults };
                
                // Copiar todos los campos del trade original
                Object.keys(trade).forEach(key => {
                    const value = trade[key];
                    
                    // Saltar metadatos internos que no queremos copiar
                    if (key.startsWith('_') && key !== '_originalId' && key !== '_source') {
                        return;
                    }
                    
                    // Manejar tipos espec√≠ficos
                    if (value === null || value === undefined || value === '') {
                        // Si el valor es nulo/vac√≠o y tenemos default, usarlo
                        if (TRADE_SCHEMA.defaults[key] !== undefined) {
                            sanitized[key] = TRADE_SCHEMA.defaults[key];
                        }
                    } else if (typeof value === 'number' || !isNaN(parseFloat(value))) {
                        // Para campos num√©ricos
                        sanitized[key] = parseFloat(value);
                    } else if (typeof value === 'string') {
                        // Para campos string
                        sanitized[key] = String(value).trim();
                    } else {
                        // Para otros tipos (boolean, array, object)
                        sanitized[key] = value;
                    }
                });
                
                // Campos especiales que siempre necesitan procesamiento
                sanitized.id = trade.id || generateId();
                sanitized.instrument = (sanitized.instrument || '').toUpperCase().trim();
                sanitized.direction = ['buy', 'sell'].includes(sanitized.direction) ? sanitized.direction : 'buy';
                
                // Fechas: asegurar formato ISO
                if (trade.entryDate) {
                    sanitized.entryDate = formatDateISO(trade.entryDate);
                }
                if (trade.exitDate) {
                    sanitized.exitDate = formatDateISO(trade.exitDate);
                }
                
                // Si no hay fechas, usar defaults
                if (!sanitized.entryDate) {
                    sanitized.entryDate = new Date().toISOString();
                    sanitized.exitDate = new Date(Date.now() + 3600000).toISOString(); // 1 hora despu√©s
                }
                
                // Metadatos
                sanitized._version = TRADE_SCHEMA.version;
                if (!sanitized._created) {
                    sanitized._created = new Date().toISOString();
                }
                sanitized._modified = new Date().toISOString();
                
                // Si viene de importaci√≥n, preservar info
                if (trade._sourceVersion) {
                    sanitized._sourceVersion = trade._sourceVersion;
                }
                if (trade._originalId) {
                    sanitized._originalId = trade._originalId;
                }
                if (trade._source) {
                    sanitized._source = trade._source;
                }
                
                return sanitized;
            } catch (e) {
                console.error('Error en sanitizeTrade:', e, trade);
                // Retornar trade m√≠nimo en caso de error
                return {
                    id: generateId(),
                    instrument: '',
                    direction: 'buy',
                    entryPrice: 0,
                    exitPrice: 0,
                    size: 1,
                    commission: 0,
                    pnl: 0,
                    pnlR: 0,
                    entryDate: new Date().toISOString(),
                    exitDate: new Date().toISOString(),
                    _version: TRADE_SCHEMA.version,
                    _created: new Date().toISOString(),
                    _modified: new Date().toISOString()
                };
            }
        }

        // ===== SISTEMA MEJORADO DE DETECCI√ìN DE TRADES INV√ÅLIDOS =====
        function detectInvalidTrades() {
            try {
                const invalidList = [];
                const duplicateMap = new Map(); // Para agrupar duplicados
                
                // Primera pasada: identificar todos los problemas
                trades.forEach((trade, index) => {
                    const issues = [];
                    let isBreakeven = false;
                    let isDuplicate = false;
                    
                    // 1. Validar schema
                    const validation = validateTradeSchema(trade);
                    if (!validation.valid) {
                        issues.push(`Schema: ${validation.error}`);
                    }
                    
                    // 2. Detectar breakeven (precios iguales)
                    if (trade.entryPrice === trade.exitPrice) {
                        isBreakeven = true;
                        issues.push('Breakeven: Precios de entrada y salida iguales');
                    }
                    
                    // 3. Detectar duplicados (solo considerar duplicados reales, no falsos positivos)
                    const duplicateKey = `${trade.instrument}_${trade.direction}_${trade.entryPrice}_${trade.entryDate}`;
                    
                    if (!duplicateMap.has(duplicateKey)) {
                        duplicateMap.set(duplicateKey, []);
                    }
                    
                    duplicateMap.get(duplicateKey).push({ trade, index });
                    
                    // 4. Detectar valores extremos
                    if (Math.abs(trade.pnlR) > 100) {
                        issues.push('Valor R extremo: ' + trade.pnlR.toFixed(2));
                    }
                    
                    if (trade.size <= 0) {
                        issues.push('Tama√±o inv√°lido: ' + trade.size);
                    }
                    
                    // 5. Verificar fechas inconsistentes
                    const entryDate = new Date(trade.entryDate);
                    const exitDate = new Date(trade.exitDate);
                    if (exitDate < entryDate) {
                        issues.push('Fecha de salida anterior a entrada');
                    }
                    
                    // 6. Verificar campos vac√≠os cr√≠ticos
                    if (!trade.instrument || trade.instrument.trim() === '') {
                        issues.push('Instrumento vac√≠o');
                    }
                    
                    if (isNaN(trade.entryPrice) || isNaN(trade.exitPrice)) {
                        issues.push('Precios inv√°lidos');
                    }
                    
                    // Si hay problemas, agregar a la lista
                    if (issues.length > 0) {
                        invalidList.push({
                            trade: trade,
                            index: index,
                            issues: issues,
                            type: 'invalid',
                            isBreakeven: isBreakeven,
                            isDuplicate: false // Se asignar√° despu√©s
                        });
                    }
                });
                
                // Segunda pasada: identificar duplicados reales (m√°s de 1 trade con misma clave)
                duplicateMap.forEach((tradesGroup, key) => {
                    if (tradesGroup.length > 1) {
                        // Todos menos el primero son duplicados
                        tradesGroup.slice(1).forEach(({ trade, index }) => {
                            // Buscar si ya est√° en la lista
                            const existing = invalidList.find(item => item.index === index);
                            if (existing) {
                                existing.isDuplicate = true;
                                existing.type = 'duplicate';
                                existing.issues.push(`Duplicado del trade ${tradesGroup[0].index + 1}`);
                            } else {
                                invalidList.push({
                                    trade: trade,
                                    index: index,
                                    issues: [`Duplicado del trade ${tradesGroup[0].index + 1}`],
                                    type: 'duplicate',
                                    isBreakeven: false,
                                    isDuplicate: true
                                });
                            }
                        });
                    }
                });
                
                // Filtrar para eliminar duplicados en la lista (por si hay overlap)
                const uniqueInvalidList = [];
                const processedIndexes = new Set();
                
                invalidList.forEach(item => {
                    if (!processedIndexes.has(item.index)) {
                        processedIndexes.add(item.index);
                        uniqueInvalidList.push(item);
                    }
                });
                
                // Ordenar por tipo y luego por √≠ndice
                uniqueInvalidList.sort((a, b) => {
                    // Orden: duplicados primero, luego inv√°lidos, luego breakeven
                    if (a.type === 'duplicate' && b.type !== 'duplicate') return -1;
                    if (a.type !== 'duplicate' && b.type === 'duplicate') return 1;
                    if (a.isBreakeven && !b.isBreakeven) return 1;
                    if (!a.isBreakeven && b.isBreakeven) return -1;
                    return a.index - b.index;
                });
                
                invalidTrades = uniqueInvalidList;
                updateInvalidTradesUI();
                return uniqueInvalidList;
                
            } catch (e) {
                console.error('Error detectando trades inv√°lidos:', e);
                return [];
            }
        }

        function updateInvalidTradesUI() {
            const count = invalidTrades.length;
            const countBadge = document.getElementById('invalidTradesCount');
            const panelCount = document.getElementById('panelInvalidCount');
            const listContainer = document.getElementById('invalidTradesList');
            
            if (countBadge) {
                countBadge.textContent = count;
                countBadge.classList.toggle('hidden', count === 0);
            }
            
            if (panelCount) {
                panelCount.textContent = count;
            }
            
            // Contar por categor√≠as
            const duplicatesCount = invalidTrades.filter(t => t.type === 'duplicate').length;
            const invalidCount = invalidTrades.filter(t => t.type === 'invalid' && !t.isBreakeven).length;
            const breakevenCount = invalidTrades.filter(t => t.isBreakeven).length;
            
            // Actualizar contadores de pesta√±as
            document.getElementById('tabAllCount').textContent = count;
            document.getElementById('tabDuplicatesCount').textContent = duplicatesCount;
            document.getElementById('tabInvalidCount').textContent = invalidCount;
            document.getElementById('tabBreakevenCount').textContent = breakevenCount;
            
            if (listContainer) {
                if (count === 0) {
                    listContainer.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--muted);">
                            ‚úÖ No se encontraron trades problem√°ticos
                        </div>
                    `;
                } else {
                    // Filtrar seg√∫n pesta√±a activa
                    let filteredTrades = invalidTrades;
                    if (currentInvalidTab === 'duplicates') {
                        filteredTrades = invalidTrades.filter(t => t.type === 'duplicate');
                    } else if (currentInvalidTab === 'invalid') {
                        filteredTrades = invalidTrades.filter(t => t.type === 'invalid' && !t.isBreakeven);
                    } else if (currentInvalidTab === 'breakeven') {
                        filteredTrades = invalidTrades.filter(t => t.isBreakeven);
                    }
                    
                    if (filteredTrades.length === 0) {
                        listContainer.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: var(--muted);">
                                No hay trades en esta categor√≠a
                            </div>
                        `;
                    } else {
                        let html = '';
                        
                        filteredTrades.forEach((invalid, idx) => {
                            const trade = invalid.trade;
                            const isSelected = selectedInvalidTrades.has(trade.id);
                            const typeColor = invalid.type === 'duplicate' ? 'var(--neon-magenta)' : 
                                            invalid.isBreakeven ? 'var(--neon-yellow)' : 'var(--neon-red)';
                            const typeIcon = invalid.type === 'duplicate' ? 'üîÅ' : 
                                           invalid.isBreakeven ? '‚öñÔ∏è' : '‚ö†Ô∏è';
                            
                            html += `
                                <div class="invalid-trade-item ${isSelected ? 'selected-invalid' : ''}" 
                                     data-id="${trade.id}" 
                                     data-index="${invalid.index}">
                                    <div style="display: flex; align-items: center; gap: 10px; flex: 1;">
                                        <input type="checkbox" class="invalid-trade-checkbox" 
                                               data-id="${trade.id}" 
                                               ${isSelected ? 'checked' : ''}
                                               style="cursor: pointer;">
                                        <div class="invalid-trade-info">
                                            <div style="font-weight: 600; color: ${typeColor};">
                                                ${typeIcon} ${trade.instrument} - ${trade.direction === 'buy' ? 'üìà BUY' : 'üìâ SELL'}
                                                <span style="font-size: 10px; color: var(--muted); margin-left: 10px;">
                                                    ${formatDateForDisplay(trade.entryDate)}
                                                </span>
                                            </div>
                                            <div style="font-size: 11px; color: var(--muted);">
                                                PnL: $${trade.pnl?.toFixed(2) || '0.00'} ‚Ä¢ 
                                                Size: ${trade.size || '1.00'} ‚Ä¢ 
                                                ${trade.strategy || 'Sin setup'}
                                            </div>
                                            <div class="invalid-trade-reason">
                                                ${invalid.issues.slice(0, 3).map(issue => `‚ö†Ô∏è ${issue}`).join(' ‚Ä¢ ')}
                                                ${invalid.issues.length > 3 ? `... (${invalid.issues.length} problemas)` : ''}
                                            </div>
                                        </div>
                                    </div>
                                    <div class="invalid-trade-actions">
                                        <button class="btn btn-secondary" style="padding: 3px 8px; font-size: 11px;"
                                                onclick="showInvalidTradeDetails(${invalid.index})">
                                            üîç Detalles
                                        </button>
                                        <button class="btn btn-primary" style="padding: 3px 8px; font-size: 11px;"
                                                onclick="restoreInvalidTrade(${invalid.index})">
                                            ‚Ü©Ô∏è Restaurar
                                        </button>
                                    </div>
                                </div>
                            `;
                        });
                        
                        listContainer.innerHTML = html;
                        
                        // Agregar event listeners para checkboxes
                        listContainer.querySelectorAll('.invalid-trade-checkbox').forEach(checkbox => {
                            checkbox.addEventListener('change', function() {
                                const tradeId = this.dataset.id;
                                if (this.checked) {
                                    selectedInvalidTrades.add(tradeId);
                                } else {
                                    selectedInvalidTrades.delete(tradeId);
                                }
                                
                                // Resaltar seleccionados
                                document.querySelectorAll('.invalid-trade-item').forEach(item => {
                                    if (selectedInvalidTrades.has(item.dataset.id)) {
                                        item.style.backgroundColor = 'rgba(0, 240, 255, 0.1)';
                                        item.style.borderColor = 'var(--neon-cyan)';
                                    } else {
                                        item.style.backgroundColor = '';
                                        item.style.borderColor = '';
                                    }
                                });
                            });
                        });
                    }
                }
            }
        }

        // ===== NUEVA FUNCI√ìN: RESTAURAR TRADE INV√ÅLIDO =====
        function restoreInvalidTrade(index) {
            const invalid = invalidTrades.find(inv => inv.index === index);
            if (!invalid) {
                showNotification('Trade no encontrado', 'error');
                return;
            }
            
            const trade = invalid.trade;
            
            try {
                // Crear backup antes de restaurar
                createBackup('pre_restore_invalid_trade');
                
                // El trade YA est√° en la lista principal (trades), solo necesitamos marcarlo como revisado
                // y actualizar su estado
                const tradeIndex = trades.findIndex(t => t.id === trade.id);
                if (tradeIndex !== -1) {
                    // Agregar metadatos de revisi√≥n
                    trades[tradeIndex]._manuallyReviewed = true;
                    trades[tradeIndex]._reviewedAt = new Date().toISOString();
                    trades[tradeIndex]._restoredFromInvalid = true;
                    
                    // Si es breakeven, asegurarnos que est√© marcado correctamente
                    if (invalid.isBreakeven) {
                        trades[tradeIndex].outcome = 'breakeven';
                    }
                    
                    // Guardar cambios
                    markUnsavedChanges();
                    saveTrades();
                    
                    // Recargar listas
                    safeLoadTrades();
                    
                    showNotification('Trade restaurado exitosamente', 'success');
                } else {
                    showNotification('Error: Trade no encontrado en lista principal', 'error');
                }
                
            } catch (e) {
                console.error('Error restaurando trade:', e);
                showNotification('Error restaurando trade', 'error');
            }
        }

        function restoreSelectedInvalidTrades() {
            if (selectedInvalidTrades.size === 0) {
                showNotification('No hay trades seleccionados', 'warning');
                return;
            }
            
            if (!confirm(`¬øRestaurar ${selectedInvalidTrades.size} trades seleccionados a la lista principal?`)) {
                return;
            }
            
            // Crear backup antes de operaci√≥n masiva
            createBackup('pre_bulk_restore_invalid');
            
            let restoredCount = 0;
            let errorCount = 0;
            
            selectedInvalidTrades.forEach(tradeId => {
                const invalid = invalidTrades.find(inv => inv.trade.id === tradeId);
                if (invalid) {
                    try {
                        restoreInvalidTrade(invalid.index);
                        restoredCount++;
                    } catch (e) {
                        errorCount++;
                        console.error(`Error restaurando trade ${tradeId}:`, e);
                    }
                }
            });
            
            selectedInvalidTrades.clear();
            
            showNotification(`${restoredCount} trades restaurados exitosamente${errorCount > 0 ? `, ${errorCount} errores` : ''}`, 
                            errorCount > 0 ? 'warning' : 'success');
        }

        function showInvalidTradeDetails(index) {
            const invalid = invalidTrades.find(inv => inv.index === index);
            if (!invalid) return;
            
            const trade = invalid.trade;
            
            const details = `
üìÑ DETALLES DEL TRADE PROBLEM√ÅTICO:

üìä INFORMACI√ìN B√ÅSICA:
‚Ä¢ ID: ${trade.id.substring(0, 12)}...
‚Ä¢ Instrumento: ${trade.instrument}
‚Ä¢ Direcci√≥n: ${trade.direction}
‚Ä¢ Entrada: ${formatDateForDisplay(trade.entryDate)}
‚Ä¢ Salida: ${formatDateForDisplay(trade.exitDate)}
‚Ä¢ Precio Entrada: ${trade.entryPrice}
‚Ä¢ Precio Salida: ${trade.exitPrice}
‚Ä¢ Tama√±o: ${trade.size}
‚Ä¢ PnL: $${trade.pnl?.toFixed(2) || '0.00'}
‚Ä¢ PnL(R): ${trade.pnlR?.toFixed(2) || '0.00'}R
‚Ä¢ Comisi√≥n: $${trade.commission || '0.00'}

‚ö†Ô∏è PROBLEMAS DETECTADOS:
${invalid.issues.map((issue, i) => `${i + 1}. ${issue}`).join('\n')}

¬øQu√© acci√≥n deseas realizar?
    `;
            
            const action = prompt(details + 
                '\n\n1. Restaurar a lista principal (como v√°lido)\n' +
                '2. Reparar autom√°ticamente\n' +
                '3. Editar manualmente\n' +
                '4. Eliminar trade\n\n' +
                'Ingresa el n√∫mero de la acci√≥n:');
            
            if (action === '1') {
                restoreInvalidTrade(index);
            } else if (action === '2') {
                repairSingleTrade(index);
            } else if (action === '3') {
                editTrade(trade.id);
                document.getElementById('invalidTradesPanel').classList.add('hidden');
            } else if (action === '4') {
                deleteTrade(trade.id);
            }
        }

        function repairSingleTrade(index) {
            const invalid = invalidTrades.find(inv => inv.index === index);
            if (!invalid) return;
            
            const trade = invalid.trade;
            
            try {
                // Crear backup antes de reparar
                createBackup('pre_repair_trade');
                
                // Intentar reparar seg√∫n los problemas detectados
                let repairedTrade = { ...trade };
                
                invalid.issues.forEach(issue => {
                    if (issue.includes('Precios inv√°lidos')) {
                        // Intentar convertir a n√∫meros
                        repairedTrade.entryPrice = parseFloat(trade.entryPrice) || 0;
                        repairedTrade.exitPrice = parseFloat(trade.exitPrice) || 0;
                    }
                    
                    if (issue.includes('Instrumento vac√≠o')) {
                        repairedTrade.instrument = 'UNKNOWN';
                    }
                    
                    if (issue.includes('Breakeven: Precios de entrada y salida iguales')) {
                        // No hacer nada - breakeven es v√°lido
                        repairedTrade.outcome = 'breakeven';
                    }
                    
                    if (issue.includes('Fecha de salida anterior a entrada')) {
                        // Intercambiar fechas
                        [repairedTrade.entryDate, repairedTrade.exitDate] = 
                        [repairedTrade.exitDate, repairedTrade.entryDate];
                    }
                    
                    if (issue.includes('Tama√±o inv√°lido')) {
                        repairedTrade.size = 1.0;
                    }
                });
                
                // Recalcular PnL con precios reparados
                repairedTrade.pnl = calculatePnl(
                    repairedTrade.entryPrice,
                    repairedTrade.exitPrice,
                    repairedTrade.size,
                    repairedTrade.direction,
                    repairedTrade.commission,
                    repairedTrade.instrument
                );
                
                repairedTrade.pnlR = calculatePnlR(
                    repairedTrade.entryPrice,
                    repairedTrade.exitPrice,
                    repairedTrade.sl || 0,
                    repairedTrade.direction
                );
                
                // Agregar metadato de reparaci√≥n
                repairedTrade._repaired = true;
                repairedTrade._repairedAt = new Date().toISOString();
                repairedTrade._repairedIssues = invalid.issues;
                
                // Actualizar el trade
                const tradeIndex = trades.findIndex(t => t.id === trade.id);
                if (tradeIndex !== -1) {
                    trades[tradeIndex] = sanitizeTrade(repairedTrade);
                }
                
                // Guardar cambios
                markUnsavedChanges();
                saveTrades();
                safeLoadTrades();
                
                showNotification('Trade reparado exitosamente', 'success');
                
            } catch (e) {
                console.error('Error reparando trade:', e);
                showNotification('Error reparando trade', 'error');
            }
        }

        function markAllTradesValid() {
            if (invalidTrades.length === 0) {
                showNotification('No hay trades para marcar como v√°lidos', 'warning');
                return;
            }
            
            if (!confirm(`¬øMarcar todos los ${invalidTrades.length} trades problem√°ticos como v√°lidos?\n\nEsto ignorar√° todas las advertencias y mantendr√° los trades en la lista principal.`)) {
                return;
            }
            
            // Crear backup antes de operaci√≥n masiva
            createBackup('pre_mark_all_valid');
            
            let markedCount = 0;
            
            invalidTrades.forEach(invalid => {
                const tradeIndex = trades.findIndex(t => t.id === invalid.trade.id);
                if (tradeIndex !== -1) {
                    // Agregar metadato indicando que fue revisado manualmente
                    trades[tradeIndex]._manuallyReviewed = true;
                    trades[tradeIndex]._reviewedAt = new Date().toISOString();
                    trades[tradeIndex]._markedValid = true;
                    
                    markedCount++;
                }
            });
            
            markUnsavedChanges();
            saveTrades();
            detectInvalidTrades();
            
            showNotification(`${markedCount} trades marcados como v√°lidos`, 'success');
        }

        // ===== IMPORTACI√ìN MEJORADA (EVITAR ACUMULACI√ìN DE DUPLICADOS) =====
        function importFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (isSafeMode) {
                showNotification('Modo seguro: No se pueden importar datos', 'warning');
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    console.log('üîç Datos importados completos:', importedData);
                    
                    if (!importedData) {
                        throw new Error('Archivo vac√≠o o inv√°lido');
                    }
                    
                    let importedTrades = [];
                    let fileVersion = importedData.version || '1.0';
                    let isSimulatorFormat = false;
                    let sourceName = 'desconocido';
                    
                    // Generar ID de sesi√≥n para evitar duplicados en la misma importaci√≥n
                    const sessionId = generateImportSessionId();
                    
                    // DETECCI√ìN DE FORMATOS
                    if (importedData.version && importedData.version === '5.0') {
                        // Formato del simulador (v5.0)
                        console.log('‚úÖ Detectado formato del simulador (v5.0)');
                        isSimulatorFormat = true;
                        sourceName = 'simulador_v5';
                        
                        if (importedData.trades && Array.isArray(importedData.trades)) {
                            importedTrades = importedData.trades;
                            console.log(`Encontrados ${importedTrades.length} trades del simulador`);
                        } else {
                            throw new Error('Formato v5.0 pero no se encontr√≥ array de trades');
                        }
                    } else if (Array.isArray(importedData)) {
                        // Array directo
                        importedTrades = importedData;
                        sourceName = 'array_directo';
                        console.log(`Encontrados ${importedTrades.length} trades (formato array)`);
                    } else if (importedData.trades && Array.isArray(importedData.trades)) {
                        // Objeto con propiedad trades
                        importedTrades = importedData.trades;
                        sourceName = importedData.meta?.sourceProgram || 'objeto_trades';
                        console.log(`Encontrados ${importedTrades.length} trades (formato objeto)`);
                    } else {
                        // √öltimo intento: buscar arrays dentro del objeto
                        for (const key in importedData) {
                            if (Array.isArray(importedData[key]) && 
                                importedData[key].length > 0 && 
                                importedData[key][0].instrument) {
                                importedTrades = importedData[key];
                                sourceName = `propiedad_${key}`;
                                console.log(`Encontrados ${importedTrades.length} trades en propiedad "${key}"`);
                                break;
                            }
                        }
                    }
                    
                    if (importedTrades.length === 0) {
                        throw new Error('No se encontraron trades en el archivo. Verifica el formato.');
                    }
                    
                    // VALIDACI√ìN Y SANITIZACI√ìN
                    const validTrades = [];
                    const invalidTradesList = [];
                    const duplicateTrades = [];
                    const seenInThisImport = new Set(); // Para evitar duplicados dentro del mismo archivo
                    
                    importedTrades.forEach((trade, index) => {
                        try {
                            // CONVERSI√ìN ESPEC√çFICA PARA FORMATO SIMULADOR
                            let sanitizedTrade;
                            
                            if (isSimulatorFormat) {
                                // Mapear campos del simulador a tu schema
                                sanitizedTrade = {
                                    id: trade.id || generateId(),
                                    instrument: (trade.instrument || '').toUpperCase().trim(),
                                    direction: trade.direction || 'buy',
                                    entryPrice: parseFloat(trade.entryPrice) || 0,
                                    exitPrice: parseFloat(trade.exitPrice) || 0,
                                    size: parseFloat(trade.size) || 1,
                                    commission: parseFloat(trade.commission) || 0,
                                    entryDate: trade.entryDate || new Date().toISOString(),
                                    exitDate: trade.exitDate || new Date().toISOString(),
                                    strategy: trade.strategy || '',
                                    timeframe: trade.timeframe || '',
                                    session: trade.session || '',
                                    sl: parseFloat(trade.sl) || 0,
                                    tp: parseFloat(trade.tp) || 0,
                                    comments: trade.comments || '',
                                    outcome: trade.outcome || null,
                                    
                                    // Campos calculados del simulador
                                    pnl: parseFloat(trade.pnl) || 0,
                                    pnlR: parseFloat(trade.pnlR) || 0,
                                    resultR: parseFloat(trade.resultR) || 0,
                                    
                                    // Metadatos
                                    _version: TRADE_SCHEMA.version,
                                    _created: trade.entryDate || new Date().toISOString(),
                                    _modified: new Date().toISOString(),
                                    _sourceVersion: fileVersion,
                                    _imported: new Date().toISOString(),
                                    _source: 'simulator_v5',
                                    _originalId: trade.id || null,
                                    _importSession: sessionId // ID de sesi√≥n para agrupar
                                };
                            } else {
                                // Formato est√°ndar
                                sanitizedTrade = sanitizeTrade(trade);
                                sanitizedTrade._sourceVersion = fileVersion;
                                sanitizedTrade._originalId = trade.id || null;
                                sanitizedTrade._source = sourceName;
                                sanitizedTrade._importSession = sessionId;
                            }
                            
                            // Validar trade
                            const validation = validateTradeSchema(sanitizedTrade);
                            
                            if (validation.valid) {
                                // Crear clave √∫nica para detecci√≥n de duplicados
                                const tradeKey = `${sanitizedTrade.instrument}_${sanitizedTrade.direction}_${sanitizedTrade.entryPrice}_${sanitizedTrade.entryDate}`;
                                
                                // Verificar duplicados dentro del mismo archivo
                                if (seenInThisImport.has(tradeKey)) {
                                    duplicateTrades.push({
                                        index: index,
                                        trade: sanitizedTrade,
                                        reason: 'Duplicado dentro del mismo archivo'
                                    });
                                    console.log(`‚ö†Ô∏è Duplicado interno en importaci√≥n: ${tradeKey}`);
                                    return;
                                }
                                
                                seenInThisImport.add(tradeKey);
                                
                                // Verificar duplicados con trades existentes
                                const existingDuplicate = trades.find(existingTrade => {
                                    const existingKey = `${existingTrade.instrument}_${existingTrade.direction}_${existingTrade.entryPrice}_${existingTrade.entryDate}`;
                                    return existingKey === tradeKey;
                                });
                                
                                if (existingDuplicate) {
                                    duplicateTrades.push({
                                        index: index,
                                        trade: sanitizedTrade,
                                        reason: 'Duplicado de trade existente'
                                    });
                                    console.log(`‚ö†Ô∏è Duplicado con trade existente: ${tradeKey}`);
                                } else {
                                    validTrades.push(sanitizedTrade);
                                }
                            } else {
                                invalidTradesList.push({ 
                                    index, 
                                    error: validation.error, 
                                    trade: sanitizedTrade 
                                });
                            }
                        } catch (tradeError) {
                            console.error(`üí• Error procesando trade ${index}:`, tradeError);
                            invalidTradesList.push({ 
                                index, 
                                error: tradeError.message, 
                                trade: trade 
                            });
                        }
                    });
                    
                    if (validTrades.length === 0 && duplicateTrades.length === 0) {
                        throw new Error(`Ning√∫n trade v√°lido despu√©s de validaci√≥n. ${invalidTradesList.length} errores encontrados.`);
                    }
                    
                    // Mostrar resumen antes de importar
                    let summaryMessage = `üìä RESUMEN DE IMPORTACI√ìN:\n\n`;
                    summaryMessage += `‚Ä¢ Trades en archivo: ${importedTrades.length}\n`;
                    summaryMessage += `‚Ä¢ Trades v√°lidos nuevos: ${validTrades.length}\n`;
                    
                    if (duplicateTrades.length > 0) {
                        summaryMessage += `‚Ä¢ Trades duplicados (omitidos): ${duplicateTrades.length}\n`;
                    }
                    
                    if (invalidTradesList.length > 0) {
                        summaryMessage += `‚Ä¢ Trades inv√°lidos (omitidos): ${invalidTradesList.length}\n`;
                    }
                    
                    summaryMessage += `\nFuente: ${sourceName} (v${fileVersion})`;
                    
                    if (!confirm(`${summaryMessage}\n\n¬øContinuar con la importaci√≥n?`)) {
                        showNotification('Importaci√≥n cancelada', 'info');
                        event.target.value = '';
                        return;
                    }
                    
                    // CREAR BACKUP ANTES DE IMPORTAR
                    createBackup('pre_import');
                    
                    // IMPORTAR TRADES V√ÅLIDOS
                    let importedCount = 0;
                    
                    validTrades.forEach(trade => {
                        trades.push(trade);
                        importedCount++;
                    });
                    
                    // GUARDAR Y ACTUALIZAR
                    markUnsavedChanges();
                    saveTrades();
                    safeLoadTrades();
                    
                    // LOG DETALLADO
                    logAction('IMPORT_JSON_SUCCESS', null, {
                        source: sourceName,
                        fileVersion: fileVersion,
                        importedCount: importedCount,
                        duplicateCount: duplicateTrades.length,
                        invalidCount: invalidTradesList.length,
                        totalInFile: importedTrades.length,
                        importSessionId: sessionId
                    });
                    
                    // MOSTRAR RESUMEN FINAL
                    let successMessage = `‚úÖ ${importedCount} trades importados exitosamente`;
                    if (duplicateTrades.length > 0) {
                        successMessage += `\n‚ö†Ô∏è ${duplicateTrades.length} duplicados omitidos`;
                    }
                    if (invalidTradesList.length > 0) {
                        successMessage += `\n‚ùå ${invalidTradesList.length} trades inv√°lidos omitidos`;
                    }
                    
                    showNotification(successMessage, 'success', 5000);
                    
                } catch (error) {
                    console.error('üí• Error cr√≠tico en importaci√≥n:', error);
                    showNotification(`‚ùå Error importando: ${error.message}`, 'error');
                    logAction('IMPORT_ERROR', null, { 
                        error: error.message,
                        stack: error.stack 
                    });
                }
                
                event.target.value = '';
            };
            
            reader.onerror = function() {
                showNotification('Error leyendo el archivo', 'error');
                event.target.value = '';
            };
            
            reader.readAsText(file);
        }

        // ===== FUNCI√ìN PRINCIPAL CORREGIDA: safeLoadTrades =====
        function safeLoadTrades() {
            try {
                console.log('üîç safeLoadTrades ejecut√°ndose...');
                console.log('Total trades en memoria:', trades.length);
                
                // Guardar referencia a noTradesRow ANTES de limpiar
                const noTradesRow = document.getElementById('noTradesRow');
                const tableBody = document.getElementById('tradesTableBody');
                
                // Si noTradesRow existe y est√° dentro de tableBody, sacarlo
                if (noTradesRow && noTradesRow.parentNode === tableBody) {
                    tableBody.removeChild(noTradesRow);
                }
                
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                
                // Filtrar trades
                let filteredTrades = trades.filter(trade => {
                    // Aplicar filtro
                    if (currentFilter === 'win' && (!trade.pnl || trade.pnl <= 0)) return false;
                    if (currentFilter === 'loss' && (!trade.pnl || trade.pnl > 0)) return false;
                    if (currentFilter === 'buy' && trade.direction !== 'buy') return false;
                    if (currentFilter === 'sell' && trade.direction !== 'sell') return false;
                    
                    // Aplicar b√∫squeda
                    if (searchTerm) {
                        const searchFields = [
                            trade.instrument,
                            trade.strategy,
                            trade.comments,
                            trade.outcome,
                            trade.session
                        ].map(f => f ? f.toLowerCase() : '');
                        
                        return searchFields.some(field => field.includes(searchTerm));
                    }
                    
                    return true;
                });
                
                console.log('Trades despu√©s de filtrar:', filteredTrades.length);
                
                // Ordenar trades
                filteredTrades.sort((a, b) => {
                    let aValue = a[currentSort.column];
                    let bValue = b[currentSort.column];
                    
                    if (currentSort.column.includes('Date')) {
                        aValue = new Date(aValue);
                        bValue = new Date(bValue);
                    }
                    
                    if (currentSort.direction === 'asc') {
                        return aValue > bValue ? 1 : -1;
                    } else {
                        return aValue < bValue ? 1 : -1;
                    }
                });
                
                // Paginaci√≥n CORREGIDA
                const totalPages = Math.max(1, Math.ceil(filteredTrades.length / TRADES_PER_PAGE));
                
                if (currentPage > totalPages) {
                    currentPage = totalPages;
                }
                
                const startIndex = (currentPage - 1) * TRADES_PER_PAGE;
                const endIndex = Math.min(startIndex + TRADES_PER_PAGE, filteredTrades.length);
                const pageTrades = filteredTrades.slice(startIndex, endIndex);
                
                console.log('Trades para mostrar en p√°gina:', pageTrades.length);
                
                // Limpiar tabla (pero preservar noTradesRow fuera del DOM)
                tableBody.innerHTML = '';
                
                if (pageTrades.length === 0) {
                    console.log('Mostrando fila "No hay trades"');
                    // Usar la referencia guardada de noTradesRow
                    if (noTradesRow) {
                        noTradesRow.style.display = '';
                        tableBody.appendChild(noTradesRow);
                    } else {
                        // Crear nueva fila si no existe
                        const newRow = document.createElement('tr');
                        newRow.id = 'noTradesRow';
                        newRow.innerHTML = `
                            <td colspan="7" style="text-align: center; padding: 40px; color: var(--muted);">
                                No hay trades registrados. Agrega tu primer trade usando el formulario.
                            </td>
                        `;
                        tableBody.appendChild(newRow);
                    }
                } else {
                    console.log('Renderizando', pageTrades.length, 'trades');
                    
                    pageTrades.forEach(trade => {
                        const row = document.createElement('tr');
                        row.dataset.id = trade.id;
                        
                        // Resaltar seleccionados
                        if (selectedTrades.has(trade.id)) {
                            row.style.backgroundColor = 'rgba(0, 240, 255, 0.1)';
                        }
                        
                        // Resaltar trades recientemente restaurados
                        if (trade._restoredFromInvalid) {
                            row.style.animation = 'pulse 2s';
                            row.style.borderLeft = '3px solid var(--neon-green)';
                        }
                        
                        // Crear checkbox para selecci√≥n
                        const checkboxHtml = `
                            <input type="checkbox" class="trade-checkbox" data-id="${trade.id}" 
                                   ${selectedTrades.has(trade.id) ? 'checked' : ''}
                                   style="margin-right: 8px; cursor: pointer;">
                        `;
                        
                        row.innerHTML = `
                            <td>
                                ${checkboxHtml}
                                ${formatDateForDisplay(trade.entryDate)}
                            </td>
                            <td>${trade.instrument || ''}</td>
                            <td class="direction-${trade.direction || 'buy'}">
                                ${trade.direction === 'buy' ? 'üìà BUY' : 'üìâ SELL'}
                            </td>
                            <td class="${(trade.pnl || 0) >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                                $${(trade.pnl || 0).toFixed(2)}
                            </td>
                            <td class="${(trade.pnlR || 0) >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                                ${(trade.pnlR || 0).toFixed(2)}R
                            </td>
                            <td>${trade.strategy || ''}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="action-btn edit-btn" data-id="${trade.id}" title="Editar">
                                        ‚úèÔ∏è
                                    </button>
                                    <button class="action-btn duplicate-btn" data-id="${trade.id}" title="Duplicar">
                                        üìã
                                    </button>
                                    <button class="action-btn delete-btn" data-id="${trade.id}" title="Eliminar">
                                        üóëÔ∏è
                                    </button>
                                </div>
                            </td>
                        `;
                        
                        tableBody.appendChild(row);
                    });
                }
                
                // Actualizar controles de paginaci√≥n
                updatePaginationControls(totalPages);
                
                // Actualizar contadores
                document.getElementById('tradeCount').textContent = 
                    `Mostrando ${pageTrades.length} de ${filteredTrades.length} trades`;
                    
                updateSelectionUI();
                updateStatistics();
                
                // Detectar trades inv√°lidos despu√©s de cargar
                setTimeout(() => {
                    detectInvalidTrades();
                }, 100);
                
                console.log('‚úÖ safeLoadTrades completado exitosamente');
                
            } catch (e) {
                console.error('‚ùå Error en safeLoadTrades:', e);
                showNotification('Error cargando trades. Verifica los datos.', 'error');
                
                // Mostrar mensaje de error en la tabla
                const tableBody = document.getElementById('tradesTableBody');
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="7" style="text-align: center; padding: 40px; color: var(--neon-red);">
                            ‚ùå Error cargando trades: ${e.message}
                            <br>
                            <button onclick="safeLoadTrades()" style="margin-top: 10px; padding: 5px 10px;">
                                Reintentar
                            </button>
                        </td>
                    </tr>
                `;
            }
        }

        // ===== CORRECCI√ìN: FUNCI√ìN DE VALIDACI√ìN DE FORMULARIO =====
        function validateForm() {
            const instrument = document.getElementById('instrument').value.trim();
            const direction = document.getElementById('direction').value;
            const entryPrice = parseFloat(document.getElementById('entryPrice').value) || 0;
            const exitPrice = parseFloat(document.getElementById('exitPrice').value) || 0;
            const entryDate = document.getElementById('entryDate').value;
            const exitDate = document.getElementById('exitDate').value;
            
            if (!instrument) {
                showNotification('El instrumento es requerido', 'error');
                document.getElementById('instrument').focus();
                return false;
            }
            
            if (!direction) {
                showNotification('La direcci√≥n es requerida', 'error');
                document.getElementById('direction').focus();
                return false;
            }
            
            if (!entryPrice || entryPrice <= 0) {
                showNotification('Precio de entrada inv√°lido', 'error');
                document.getElementById('entryPrice').focus();
                return false;
            }
            
            if (!exitPrice || exitPrice <= 0) {
                showNotification('Precio de salida inv√°lido', 'error');
                document.getElementById('exitPrice').focus();
                return false;
            }
            
            // PERMITIR BREAKEVEN - Eliminar validaci√≥n de precios diferentes
            // Los trades en breakeven (entryPrice === exitPrice) son v√°lidos
            
            if (!entryDate) {
                showNotification('Fecha de entrada es requerida', 'error');
                return false;
            }
            
            if (!exitDate) {
                showNotification('Fecha de salida es requerida', 'error');
                return false;
            }
            
            const entry = new Date(entryDate);
            const exit = new Date(exitDate);
            if (exit <= entry) {
                showNotification('Fecha de salida debe ser posterior a fecha de entrada', 'error');
                return false;
            }
            
            return true;
        }

        // ===== CONFIGURACI√ìN DE EVENT LISTENERS PARA TRADES INV√ÅLIDOS =====
        function setupInvalidTradesListeners() {
            // Bot√≥n para mostrar panel
            document.getElementById('showInvalidTradesBtn')?.addEventListener('click', function() {
                const panel = document.getElementById('invalidTradesPanel');
                panel.classList.toggle('hidden');
                
                // Actualizar lista al mostrar
                if (!panel.classList.contains('hidden')) {
                    detectInvalidTrades();
                }
            });
            
            // Bot√≥n para cerrar panel
            document.getElementById('closeInvalidPanel')?.addEventListener('click', function() {
                document.getElementById('invalidTradesPanel').classList.add('hidden');
            });
            
            // Pesta√±as
            document.querySelectorAll('.invalid-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelectorAll('.invalid-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentInvalidTab = this.dataset.tab;
                    updateInvalidTradesUI();
                });
            });
            
            // Bot√≥n restaurar seleccionados
            document.getElementById('restoreSelectedInvalidBtn')?.addEventListener('click', restoreSelectedInvalidTrades);
            
            // Bot√≥n reparar seleccionados
            document.getElementById('repairSelectedInvalidBtn')?.addEventListener('click', repairSelectedInvalidTrades);
            
            // Bot√≥n eliminar seleccionados
            document.getElementById('deleteSelectedInvalidBtn')?.addEventListener('click', deleteSelectedInvalidTrades);
            
            // Bot√≥n marcar todos como v√°lidos
            document.getElementById('markAllValidBtn')?.addEventListener('click', markAllTradesValid);
            
            // Bot√≥n exportar lista
            document.getElementById('exportInvalidBtn')?.addEventListener('click', exportInvalidTradesList);
        }

        // ===== INICIALIZACI√ìN =====
        function loadInitialData() {
            try {
                const stored = localStorage.getItem(TRADE_STORAGE_KEY);
                
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (Array.isArray(parsed)) {
                        trades = parsed.map(trade => sanitizeTrade(trade));
                        
                        // Filtrar solo trades v√°lidos
                        const validTrades = trades.filter(trade => {
                            const validation = validateTradeSchema(trade);
                            return validation.valid;
                        });
                        
                        console.log(`Cargados ${validTrades.length}/${parsed.length} trades v√°lidos desde localStorage`);
                        trades = validTrades;
                    }
                }
                
                // Configurar fechas por defecto
                const now = new Date();
                const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
                
                document.getElementById('entryDate').value = formatDateForInput(oneHourAgo);
                document.getElementById('exitDate').value = formatDateForInput(now);
                
                // Cargar y renderizar
                safeLoadTrades();
                
            } catch (e) {
                console.error('Error loading initial data:', e);
                trades = [];
                showNotification('Error cargando datos, iniciando en modo seguro', 'error');
            }
        }

        function setupEventListeners() {
            // Formulario
            document.getElementById('addTradeBtn').addEventListener('click', addTrade);
            document.getElementById('updateTradeBtn').addEventListener('click', updateTrade);
            document.getElementById('resetFormBtn').addEventListener('click', resetForm);
            document.getElementById('cancelEditBtn').addEventListener('click', resetForm);
            
            // B√∫squeda con debouncing
            document.getElementById('searchInput').addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    currentPage = 1;
                    safeLoadTrades();
                }, 300);
            });
            
            // Filtros
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentFilter = this.dataset.filter;
                    currentPage = 1;
                    safeLoadTrades();
                });
            });
            
            // Ordenamiento
            document.querySelectorAll('#tradesTable th[data-sort]').forEach(th => {
                th.addEventListener('click', function() {
                    const column = this.dataset.sort;
                    
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = column;
                        currentSort.direction = 'asc';
                    }
                    
                    // Actualizar indicadores visuales
                    document.querySelectorAll('#tradesTable th').forEach(h => {
                        h.classList.remove('sort-asc', 'sort-desc');
                    });
                    this.classList.add(`sort-${currentSort.direction}`);
                    
                    safeLoadTrades();
                });
            });
            
            // Importaci√≥n/Exportaci√≥n
            document.getElementById('exportCsvBtn').addEventListener('click', exportToCSV);
            document.getElementById('exportJsonBtn').addEventListener('click', exportToJSON);
            document.getElementById('importJsonInput').addEventListener('change', importFromJSON);
            
            // Trades inv√°lidos
            setupInvalidTradesListeners();
            
            // Gestor de backups
            document.getElementById('backupManagerBtn').addEventListener('click', showBackupManager);
            document.getElementById('createBackupBtn').addEventListener('click', function() {
                createBackup('manual');
                setTimeout(showBackupManager, 1000);
            });
            document.getElementById('restoreLatestBtn').addEventListener('click', function() {
                const backups = getAvailableBackups();
                if (backups.length > 0) {
                    restoreBackup(backups[0].id);
                } else {
                    showNotification('No hay backups disponibles', 'warning');
                }
            });
            document.getElementById('closeBackupModal').addEventListener('click', function() {
                document.getElementById('backupModal').classList.add('hidden');
            });
            
            // Delegaci√≥n de eventos para acciones de backup
            document.getElementById('backupList').addEventListener('click', function(e) {
                const button = e.target.closest('button');
                if (!button) return;
                
                const backupId = button.dataset.backupId;
                const action = button.dataset.action;
                
                if (action === 'restore') {
                    if (confirm('¬øRestaurar este backup? Los datos actuales ser√°n reemplazados.')) {
                        restoreBackup(backupId);
                        document.getElementById('backupModal').classList.add('hidden');
                    }
                } else if (action === 'delete') {
                    if (confirm('¬øEliminar permanentemente este backup?')) {
                        localStorage.removeItem(backupId);
                        showNotification('Backup eliminado', 'warning');
                        setTimeout(showBackupManager, 500);
                    }
                }
            });
            
            // Selecci√≥n m√∫ltiple
            document.getElementById('selectAllBtn').addEventListener('click', function() {
                try {
                    const checkboxes = document.querySelectorAll('.trade-checkbox');
                    
                    if (checkboxes.length === 0) return;
                    
                    const allSelected = Array.from(checkboxes).every(cb => cb.checked);
                    
                    checkboxes.forEach(cb => {
                        cb.checked = !allSelected;
                        const tradeId = cb.dataset.id;
                        if (tradeId) {
                            if (!allSelected) {
                                selectedTrades.add(tradeId);
                            } else {
                                selectedTrades.delete(tradeId);
                            }
                        }
                    });
                    
                    highlightSelectedRows();
                    updateSelectionUI();
                    
                } catch (error) {
                    console.error('Error en selecci√≥n m√∫ltiple:', error);
                    showNotification('Error en selecci√≥n. Intenta nuevamente.', 'error');
                }
            });
            
            // Eliminaci√≥n de seleccionados
            document.getElementById('deleteSelectedBtn').addEventListener('click', function() {
                if (selectedTrades.size === 0 || isSafeMode) {
                    if (isSafeMode) {
                        showNotification('Modo seguro activado', 'warning');
                    }
                    return;
                }
                
                if (!confirm(`¬øEliminar ${selectedTrades.size} trades seleccionados?`)) return;
                
                try {
                    // Crear backup antes de eliminar
                    createBackup('pre_bulk_delete');
                    
                    const newTrades = trades.filter(t => !selectedTrades.has(t.id));
                    const deletedCount = trades.length - newTrades.length;
                    
                    trades = newTrades;
                    selectedTrades.clear();
                    markUnsavedChanges();
                    
                    if (saveTrades()) {
                        safeLoadTrades();
                        logAction('BULK_DELETE', null, { deletedCount });
                        showNotification(`${deletedCount} trades eliminados`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Error eliminando trades seleccionados:', error);
                    showNotification('Error eliminando trades. Los datos se mantienen intactos.', 'error');
                    safeLoadTrades();
                }
            });
            
            // Delegaci√≥n de eventos para acciones de tabla
            document.getElementById('tradesTableBody').addEventListener('click', function(e) {
                const target = e.target;
                const tradeId = target.closest('button')?.dataset.id;
                const checkbox = target.closest('.trade-checkbox');
                
                if (checkbox) {
                    // Manejar selecci√≥n de checkbox
                    const tradeId = checkbox.dataset.id;
                    if (checkbox.checked) {
                        selectedTrades.add(tradeId);
                    } else {
                        selectedTrades.delete(tradeId);
                    }
                    highlightSelectedRows();
                    updateSelectionUI();
                    return;
                }
                
                if (!tradeId) return;
                
                if (target.classList.contains('edit-btn')) {
                    editTrade(tradeId);
                    logAction('EDIT_START', tradeId);
                } else if (target.classList.contains('delete-btn')) {
                    deleteTrade(tradeId);
                } else if (target.classList.contains('duplicate-btn')) {
                    duplicateTrade(tradeId);
                    logAction('DUPLICATE', tradeId);
                }
            });
            
            // Recuperaci√≥n de datos
            document.getElementById('repairDataBtn').addEventListener('click', function() {
                showLoading(this, true);
                setTimeout(() => {
                    const result = repairData();
                    showLoading(this, false);
                    showNotification(`Datos reparados: ${result.repaired} trades recuperados`, 'success');
                    document.getElementById('recoveryModal').classList.add('hidden');
                    isSafeMode = false;
                    safeLoadTrades();
                    startAutoSave();
                }, 500);
            });
            
            document.getElementById('resetDataBtn').addEventListener('click', function() {
                if (confirm('‚ö†Ô∏è ¬øEST√ÅS SEGURO? Esto eliminar√° TODOS los datos permanentemente.')) {
                    // Crear √∫ltimo backup
                    createBackup('pre_reset');
                    
                    localStorage.removeItem(TRADE_STORAGE_KEY);
                    localStorage.removeItem(BACKUP_KEY);
                    trades = [];
                    saveTrades();
                    
                    logAction('DATA_RESET', null, {});
                    
                    showNotification('Todos los datos han sido reseteados', 'warning');
                    document.getElementById('recoveryModal').classList.add('hidden');
                    isSafeMode = false;
                    safeLoadTrades();
                    startAutoSave();
                }
            });
            
            document.getElementById('ignoreBtn').addEventListener('click', function() {
                document.getElementById('recoveryModal').classList.add('hidden');
                trades = [];
                safeLoadTrades();
                startAutoSave();
            });
            
            // Bot√≥n gestor de datos
            document.getElementById('dataManagerBtn').addEventListener('click', function() {
                const stats = checkDataHealth();
                const backups = getAvailableBackups();
                const logs = getActionLogs(10);
                
                let logSummary = '';
                logs.forEach(log => {
                    const time = new Date(log.timestamp).toLocaleTimeString();
                    logSummary += `\n${time} - ${log.action}${log.tradeId ? ' (' + log.tradeId.substring(0, 8) + '...)' : ''}`;
                });
                
                alert(`üìä GESTOR DE DATOS v3.1:\n\n` +
                      `‚Ä¢ Trades actuales: ${trades.length}\n` +
                      `‚Ä¢ Trades problem√°ticos: ${invalidTrades.length}\n` +
                      `‚Ä¢ Salud datos: ${stats.healthy ? '‚úÖ OK' : '‚ùå CORRUPTO'}\n` +
                      `‚Ä¢ Raz√≥n: ${stats.reason}\n` +
                      `‚Ä¢ Backups disponibles: ${backups.length}\n` +
                      `‚Ä¢ Modo seguro: ${isSafeMode ? '‚úÖ ACTIVO' : '‚ùå INACTIVO'}\n` +
                      `‚Ä¢ Trades seleccionados: ${selectedTrades.size}\n` +
                      `‚Ä¢ √öltimas acciones:${logSummary || ' Ninguna'}\n` +
                      `‚Ä¢ √öltima p√°gina: ${currentPage}`);
            });
            
            // Bot√≥n de debug
            document.getElementById('debugBtn').addEventListener('click', function() {
                console.group('üîç DEBUG INFO');
                console.log('Trades:', trades);
                console.log('Trades problem√°ticos:', invalidTrades);
                console.log('Selected trades:', Array.from(selectedTrades));
                console.log('Current sort:', currentSort);
                console.log('Current filter:', currentFilter);
                console.log('Current page:', currentPage);
                console.log('Is safe mode:', isSafeMode);
                console.log('Has unsaved changes:', hasUnsavedChanges);
                console.log('Schema version:', TRADE_SCHEMA.version);
                console.log('Import session ID:', importSessionId);
                console.groupEnd();
                
                showNotification('Informaci√≥n de debug mostrada en consola', 'info');
            });
        }

        function setupAutoCalculations() {
            const fields = ['entryPrice', 'exitPrice', 'size', 'commission', 'sl'];
            fields.forEach(field => {
                document.getElementById(field).addEventListener('input', updateCalculatedFields);
            });
            
            document.getElementById('direction').addEventListener('change', updateCalculatedFields);
            document.getElementById('instrument').addEventListener('input', updateCalculatedFields);
        }

        function updateCalculatedFields() {
            try {
                const entryPrice = parseFloat(document.getElementById('entryPrice').value) || 0;
                const exitPrice = parseFloat(document.getElementById('exitPrice').value) || 0;
                const size = parseFloat(document.getElementById('size').value) || 1;
                const direction = document.getElementById('direction').value;
                const commission = parseFloat(document.getElementById('commission').value) || 0;
                const instrument = document.getElementById('instrument').value;
                const sl = parseFloat(document.getElementById('sl').value) || 0;
                
                if (entryPrice && exitPrice && size && direction) {
                    const pnl = calculatePnl(entryPrice, exitPrice, size, direction, commission, instrument);
                    const pnlR = calculatePnlR(entryPrice, exitPrice, sl, direction);
                    
                    document.getElementById('pnl').value = pnl.toFixed(2);
                    document.getElementById('pnlR').value = pnlR.toFixed(2);
                }
            } catch (e) {
                console.error('Error updating calculated fields:', e);
            }
        }

        function setupAutocomplete() {
            const instrumentInput = document.getElementById('instrument');
            const instrumentList = document.getElementById('instrumentList');
            
            INSTRUMENTS.forEach(instrument => {
                const option = document.createElement('option');
                option.value = instrument;
                instrumentList.appendChild(option);
            });
            
            // Autocompletar estrategias
            instrumentInput.addEventListener('input', function() {
                const value = this.value.toUpperCase();
                if (value && !INSTRUMENTS.includes(value)) {
                    INSTRUMENTS.push(value);
                    const option = document.createElement('option');
                    option.value = value;
                    instrumentList.appendChild(option);
                }
            });
        }

        function startAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            
            autoSaveTimer = setInterval(() => {
                if (hasUnsavedChanges && !isSafeMode) {
                    saveTrades();
                }
            }, 60000); // Auto-save cada minuto
            
            // Auto-backup cada 5 minutos
            setInterval(() => {
                if (!isSafeMode && trades.length > 0) {
                    createBackup('auto_schedule');
                }
            }, BACKUP_CONFIG.autoSaveInterval);
        }

        // ===== SISTEMA DE BACKUP Y LOGS MEJORADO =====
        function createBackup(reason = 'manual') {
            try {
                const timestamp = new Date().toISOString();
                const backupId = BACKUP_CONFIG.prefix + timestamp.replace(/[:.]/g, '-');
                
                const backup = {
                    id: backupId,
                    timestamp: timestamp,
                    reason: reason,
                    data: JSON.parse(JSON.stringify(trades)),
                    stats: {
                        tradeCount: trades.length,
                        totalPnL: trades.reduce((sum, t) => sum + (t.pnl || 0), 0),
                        winRate: trades.length > 0 ? 
                            (trades.filter(t => (t.pnl || 0) > 0).length / trades.length * 100).toFixed(1) + '%' : '0%'
                    },
                    checksum: calculateDataChecksum(trades),
                    version: '3.0'
                };
                
                localStorage.setItem(backupId, JSON.stringify(backup));
                logAction('BACKUP_CREATED', null, { reason, backupId, tradeCount: trades.length });
                
                // Limpiar backups antiguos
                cleanupOldBackups();
                
                showNotification(`Backup creado: ${reason}`, 'success', 2000);
                return backupId;
            } catch (e) {
                console.error('Error creando backup:', e);
                showNotification('Error creando backup', 'error');
                return null;
            }
        }

        function cleanupOldBackups() {
            try {
                const backupKeys = [];
                
                // Encontrar todos los backups
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(BACKUP_CONFIG.prefix)) {
                        backupKeys.push(key);
                    }
                }
                
                // Ordenar por timestamp (m√°s reciente primero)
                backupKeys.sort((a, b) => {
                    const timeA = new Date(a.replace(BACKUP_CONFIG.prefix, '').replace(/-/g, ':').replace(/-/g, '.'));
                    const timeB = new Date(b.replace(BACKUP_CONFIG.prefix, '').replace(/-/g, ':').replace(/-/g, '.'));
                    return timeB - timeA;
                });
                
                // Eliminar backups antiguos
                if (backupKeys.length > BACKUP_CONFIG.maxBackups) {
                    const toDelete = backupKeys.slice(BACKUP_CONFIG.maxBackups);
                    toDelete.forEach(key => {
                        localStorage.removeItem(key);
                        logAction('BACKUP_DELETED', null, { key });
                    });
                }
            } catch (e) {
                console.error('Error limpiando backups:', e);
            }
        }

        function getAvailableBackups() {
            try {
                const backups = [];
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(BACKUP_CONFIG.prefix)) {
                        try {
                            const backup = JSON.parse(localStorage.getItem(key));
                            if (backup && backup.timestamp) {
                                backups.push({
                                    id: key,
                                    timestamp: backup.timestamp,
                                    reason: backup.reason || 'unknown',
                                    tradeCount: backup.stats?.tradeCount || 0,
                                    totalPnL: backup.stats?.totalPnL || 0,
                                    winRate: backup.stats?.winRate || '0%'
                                });
                            }
                        } catch (e) {
                            console.warn('Backup corrupto:', key, e);
                        }
                    }
                }
                
                // Ordenar por fecha (m√°s reciente primero)
                return backups.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            } catch (e) {
                console.error('Error obteniendo backups:', e);
                return [];
            }
        }

        function restoreBackup(backupId) {
            try {
                const backup = JSON.parse(localStorage.getItem(backupId));
                if (!backup || !backup.data) {
                    throw new Error('Backup no v√°lido');
                }
                
                // Validar datos del backup
                const validatedTrades = backup.data
                    .map(trade => sanitizeTrade(trade))
                    .filter(trade => {
                        const validation = validateTradeSchema(trade);
                        return validation.valid;
                    });
                
                if (validatedTrades.length === 0 && backup.data.length > 0) {
                    throw new Error('Backup corrupto: ning√∫n trade v√°lido encontrado');
                }
                
                // Preguntar confirmaci√≥n
                if (!confirm(`¬øRestaurar backup con ${validatedTrades.length} trades?\n\nFecha: ${new Date(backup.timestamp).toLocaleString()}\nMotivo: ${backup.reason}`)) {
                    return false;
                }
                
                // Crear backup actual antes de restaurar
                createBackup('pre_restore');
                
                // Restaurar
                trades = validatedTrades;
                saveTrades();
                
                logAction('BACKUP_RESTORED', null, {
                    backupId,
                    restoredTrades: validatedTrades.length,
                    originalTrades: backup.data.length
                });
                
                showNotification(`Backup restaurado: ${validatedTrades.length} trades`, 'success');
                safeLoadTrades();
                
                return true;
            } catch (e) {
                console.error('Error restaurando backup:', e);
                showNotification(`Error restaurando backup: ${e.message}`, 'error');
                return false;
            }
        }

        function calculateDataChecksum(data) {
            try {
                const str = JSON.stringify(data);
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString(36);
            } catch (e) {
                return 'error';
            }
        }

        // ===== SISTEMA DE LOGS =====
        function logAction(action, tradeId = null, details = {}) {
            try {
                const logs = JSON.parse(localStorage.getItem(ACTION_LOG_KEY) || '[]');
                
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    action: action,
                    tradeId: tradeId,
                    details: details,
                    userAgent: navigator.userAgent.substring(0, 100),
                    sessionId: getSessionId()
                };
                
                logs.push(logEntry);
                
                // Mantener l√≠mite de logs
                if (logs.length > BACKUP_CONFIG.maxLogEntries) {
                    logs.splice(0, logs.length - BACKUP_CONFIG.maxLogEntries);
                }
                
                localStorage.setItem(ACTION_LOG_KEY, JSON.stringify(logs));
                return true;
            } catch (e) {
                console.error('Error registrando log:', e);
                return false;
            }
        }

        function getSessionId() {
            let sessionId = sessionStorage.getItem('trading_session_id');
            if (!sessionId) {
                sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                sessionStorage.setItem('trading_session_id', sessionId);
            }
            return sessionId;
        }

        function getActionLogs(limit = 50) {
            try {
                const logs = JSON.parse(localStorage.getItem(ACTION_LOG_KEY) || '[]');
                return logs.slice(-limit).reverse();
            } catch (e) {
                return [];
            }
        }

        // ===== RECUPERACI√ìN Y REPARACI√ìN =====
        function checkDataHealth() {
            try {
                const stored = localStorage.getItem(TRADE_STORAGE_KEY);
                if (!stored) return { healthy: true, reason: 'No data' };
                
                const parsed = JSON.parse(stored);
                if (!Array.isArray(parsed)) {
                    return { 
                        healthy: false, 
                        reason: 'Data is not an array',
                        data: parsed 
                    };
                }
                
                // Verificar cada trade
                let invalidCount = 0;
                for (let i = 0; i < parsed.length; i++) {
                    const validation = validateTradeSchema(parsed[i]);
                    if (!validation.valid) {
                        invalidCount++;
                        console.warn(`Trade ${i} inv√°lido:`, validation.error, parsed[i]);
                    }
                }
                
                if (invalidCount > 0) {
                    return {
                        healthy: false,
                        reason: `${invalidCount} trades inv√°lidos encontrados`,
                        invalidCount: invalidCount,
                        totalCount: parsed.length
                    };
                }
                
                return { healthy: true, reason: 'All trades valid' };
                
            } catch (e) {
                return {
                    healthy: false,
                    reason: `Parse error: ${e.message}`,
                    error: e
                };
            }
        }

        function repairData() {
            try {
                const stored = localStorage.getItem(TRADE_STORAGE_KEY);
                let originalData = [];
                let repairedCount = 0;
                
                if (stored) {
                    const parsed = JSON.parse(stored);
                    originalData = parsed;
                    
                    if (!Array.isArray(parsed)) {
                        // Intentar extraer trades de diferentes formatos
                        let extracted = [];
                        if (parsed.trades && Array.isArray(parsed.trades)) {
                            extracted = parsed.trades;
                        } else if (typeof parsed === 'object') {
                            // Buscar arrays en el objeto
                            Object.values(parsed).forEach(value => {
                                if (Array.isArray(value) && value.length > 0 && value[0].instrument) {
                                    extracted = value;
                                }
                            });
                        }
                        
                        trades = extracted.map(trade => sanitizeTrade(trade));
                    } else {
                        // Es array, sanitizar
                        trades = parsed.map(trade => sanitizeTrade(trade));
                    }
                    
                    // Filtrar trades v√°lidos
                    const validTrades = trades.filter(trade => {
                        const validation = validateTradeSchema(trade);
                        return validation.valid;
                    });
                    
                    repairedCount = validTrades.length;
                    trades = validTrades;
                }
                
                saveTrades();
                createBackup('data_repair');
                
                return { 
                    repaired: repairedCount, 
                    total: originalData.length,
                    originalData: originalData 
                };
                
            } catch (e) {
                console.error('Error repairing data:', e);
                trades = restoreBackupLatest() || [];
                saveTrades();
                return { 
                    repaired: trades.length, 
                    total: 0, 
                    error: e.message 
                };
            }
        }

        // ===== SISTEMA DE GESTI√ìN DE DATOS =====
        function saveTrades() {
            try {
                if (isSafeMode) {
                    console.warn('Modo seguro: Los datos no se guardar√°n.');
                    return false;
                }
                
                // Crear backup antes de guardar
                backupData();
                
                // Guardar solo trades v√°lidos
                const validTrades = trades.filter(trade => {
                    const validation = validateTradeSchema(trade);
                    if (!validation.valid) {
                        console.warn('Trade inv√°lido omitido:', validation.error, trade);
                        return false;
                    }
                    return true;
                });
                
                localStorage.setItem(TRADE_STORAGE_KEY, JSON.stringify(validTrades));
                
                // Actualizar estad√≠sticas
                updateStatistics();
                
                hasUnsavedChanges = false;
                return true;
            } catch (e) {
                console.error('Error saving trades:', e);
                showNotification('Error guardando datos. Verifica el almacenamiento.', 'error');
                return false;
            }
        }

        function backupData() {
            try {
                localStorage.setItem(BACKUP_KEY, JSON.stringify({
                    timestamp: new Date().toISOString(),
                    trades: trades,
                    count: trades.length,
                    checksum: calculateDataChecksum(trades),
                    version: '3.0'
                }));
                return true;
            } catch (e) {
                console.error('Error haciendo backup:', e);
                return false;
            }
        }

        function restoreBackupLatest() {
            try {
                const backup = localStorage.getItem(BACKUP_KEY);
                if (backup) {
                    const data = JSON.parse(backup);
                    if (data.trades && Array.isArray(data.trades)) {
                        return data.trades;
                    }
                }
            } catch (e) {
                console.error('Error restaurando backup:', e);
            }
            return [];
        }

        function markUnsavedChanges() {
            hasUnsavedChanges = true;
            document.title = "TRADING SUITE * | Programa 1 - Gesti√≥n de Trades";
        }

        // ===== INTERFAZ DE USUARIO =====
        function updateSelectionUI() {
            const selectedCount = selectedTrades.size;
            const deleteBtn = document.getElementById('deleteSelectedBtn');
            const selectedCountSpan = document.getElementById('selectedCount');
            
            selectedCountSpan.textContent = selectedCount;
            
            if (selectedCount > 0) {
                deleteBtn.style.display = 'inline-flex';
            } else {
                deleteBtn.style.display = 'none';
            }
        }

        function highlightSelectedRows() {
            document.querySelectorAll('#tradesTableBody tr').forEach(row => {
                const tradeId = row.dataset.id;
                row.style.backgroundColor = selectedTrades.has(tradeId) 
                    ? 'rgba(0, 240, 255, 0.1)' 
                    : '';
            });
        }

        // ===== ESTAD√çSTICAS =====
        function updateStatistics() {
            if (trades.length === 0) {
                document.getElementById('statTotalTrades').textContent = '0';
                document.getElementById('statWinRate').textContent = '0%';
                document.getElementById('statProfitFactor').textContent = '0.00';
                document.getElementById('statExpectancy').textContent = '0.00';
                document.getElementById('statBestTrade').textContent = '0.00';
                document.getElementById('statWorstTrade').textContent = '0.00';
                return;
            }
            
            const winningTrades = trades.filter(t => (t.pnl || 0) > 0);
            const losingTrades = trades.filter(t => (t.pnl || 0) < 0);
            
            // Win Rate
            const winRate = trades.length > 0 ? 
                (winningTrades.length / trades.length * 100).toFixed(1) : 0;
            
            // Profit Factor
            const totalProfit = winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
            const totalLoss = Math.abs(losingTrades.reduce((sum, t) => sum + (t.pnl || 0), 0));
            const profitFactor = totalLoss > 0 ? (totalProfit / totalLoss).toFixed(2) : '‚àû';
            
            // Expectancy (R)
            const avgWinR = winningTrades.length > 0 ? 
                winningTrades.reduce((sum, t) => sum + (t.pnlR || 0), 0) / winningTrades.length : 0;
            const avgLossR = losingTrades.length > 0 ? 
                losingTrades.reduce((sum, t) => sum + (t.pnlR || 0), 0) / losingTrades.length : 0;
            const winProbability = winningTrades.length / trades.length;
            const expectancy = (winProbability * avgWinR) - ((1 - winProbability) * Math.abs(avgLossR));
            
            // Mejor y peor trade (R)
            const bestTrade = Math.max(...trades.map(t => t.pnlR || 0));
            const worstTrade = Math.min(...trades.map(t => t.pnlR || 0));
            
            // Actualizar UI
            document.getElementById('statTotalTrades').textContent = trades.length;
            document.getElementById('statWinRate').textContent = `${winRate}%`;
            document.getElementById('statProfitFactor').textContent = profitFactor;
            document.getElementById('statExpectancy').textContent = expectancy.toFixed(2);
            document.getElementById('statBestTrade').textContent = bestTrade.toFixed(2);
            document.getElementById('statWorstTrade').textContent = worstTrade.toFixed(2);
            document.getElementById('statWorstTrade').className = worstTrade < 0 ? 'stat-value negative' : 'stat-value';
            
            // Actualizar tiempo
            document.getElementById('statsUpdateTime').textContent = 
                `Actualizado: ${new Date().toLocaleTimeString('es-ES', {hour: '2-digit', minute:'2-digit'})}`;
        }

        // ===== EXPORTACI√ìN =====
        function exportToJSON() {
            if (trades.length === 0) {
                showNotification('No hay datos para exportar', 'warning');
                return;
            }
            
            try {
                const exportData = {
                    version: '3.0',
                    meta: {
                        exportDate: new Date().toISOString(),
                        sourceProgram: 'programa-1',
                        tradesCount: trades.length,
                        totalPnL: trades.reduce((sum, t) => sum + (t.pnl || 0), 0),
                        winRate: trades.length > 0 ? 
                            (trades.filter(t => (t.pnl || 0) > 0).length / trades.length * 100).toFixed(1) + '%' : '0%',
                        dataFormat: 'trading_suite_standard_v3',
                        schemaVersion: TRADE_SCHEMA.version,
                        checksum: calculateDataChecksum(trades)
                    },
                    trades: trades.map(trade => {
                        // Exportar todos los campos, incluyendo metadatos
                        const exportTrade = { ...trade };
                        
                        // Asegurar formato ISO para fechas
                        exportTrade.entryDate = formatDateISO(exportTrade.entryDate);
                        exportTrade.exitDate = formatDateISO(exportTrade.exitDate);
                        
                        return exportTrade;
                    })
                };
                
                const jsonContent = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                
                link.href = url;
                link.setAttribute('download', `trades_${new Date().toISOString().slice(0, 10)}_v3.json`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                logAction('EXPORT_JSON', null, { tradeCount: trades.length });
                showNotification('JSON exportado exitosamente', 'success');
                
            } catch (e) {
                console.error('Error exporting JSON:', e);
                showNotification('Error exportando JSON', 'error');
            }
        }

        function exportToCSV() {
            if (trades.length === 0) {
                showNotification('No hay datos para exportar', 'warning');
                return;
            }
            
            try {
                const headers = [
                    'ID', 'Fecha Entrada', 'Fecha Salida', 'Instrumento', 'Setup', 'Temporalidad', 'Sesi√≥n',
                    'Direcci√≥n', 'Precio Entrada', 'Precio Salida', 'SL', 'TP', 'Tama√±o', 'Comisi√≥n',
                    'Resultado (R)', 'PnL', 'PnL (R)', 'Outcome', 'Comentarios', 'Versi√≥n', 'Creado', 'Modificado'
                ];
                
                const csvRows = [
                    headers.join(','),
                    ...trades.map(trade => [
                        `"${trade.id}"`,
                        `"${trade.entryDate}"`,
                        `"${trade.exitDate}"`,
                        `"${trade.instrument || ''}"`,
                        `"${trade.strategy || ''}"`,
                        `"${trade.timeframe || ''}"`,
                        `"${trade.session || ''}"`,
                        trade.direction,
                        trade.entryPrice || 0,
                        trade.exitPrice || 0,
                        trade.sl || 0,
                        trade.tp || 0,
                        trade.size || 0,
                        trade.commission || 0,
                        trade.resultR || 0,
                        trade.pnl || 0,
                        trade.pnlR || 0,
                        `"${trade.outcome || ''}"`,
                        `"${(trade.comments || '').replace(/"/g, '""')}"`,
                        trade._version || '1.0',
                        `"${trade._created || ''}"`,
                        `"${trade._modified || ''}"`
                    ].join(','))
                ];
                
                const csvContent = csvRows.join('\n');
                const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                
                link.href = url;
                link.setAttribute('download', `trades_${new Date().toISOString().slice(0, 10)}_v3.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                logAction('EXPORT_CSV', null, { tradeCount: trades.length });
                showNotification('CSV exportado exitosamente', 'success');
                
            } catch (e) {
                console.error('Error exporting CSV:', e);
                showNotification('Error exportando CSV', 'error');
            }
        }

        function exportInvalidTradesList() {
            if (invalidTrades.length === 0) {
                showNotification('No hay trades inv√°lidos para exportar', 'warning');
                return;
            }
            
            try {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    totalInvalid: invalidTrades.length,
                    invalidTrades: invalidTrades.map(invalid => ({
                        trade: invalid.trade,
                        issues: invalid.issues,
                        type: invalid.type,
                        originalIndex: invalid.index
                    }))
                };
                
                const jsonContent = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                
                link.href = url;
                link.setAttribute('download', `invalid_trades_${new Date().toISOString().slice(0, 10)}.json`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                showNotification('Lista de trades inv√°lidos exportada', 'success');
                
            } catch (e) {
                console.error('Error exportando lista:', e);
                showNotification('Error exportando lista', 'error');
            }
        }

        // ===== FUNCIONES PRINCIPALES CORREGIDAS =====
        function addTrade() {
            if (isSafeMode) {
                showNotification('Modo seguro: No se pueden agregar trades', 'warning');
                return;
            }
            
            if (!validateForm()) {
                return;
            }
            
            try {
                // Obtener valores del formulario
                const entryDate = formatDateISO(document.getElementById('entryDate').value);
                const exitDate = formatDateISO(document.getElementById('exitDate').value);
                const instrument = document.getElementById('instrument').value;
                const strategy = document.getElementById('strategy').value;
                const timeframe = document.getElementById('timeframe').value;
                const direction = document.getElementById('direction').value;
                const entryPrice = parseFloat(document.getElementById('entryPrice').value) || 0;
                const exitPrice = parseFloat(document.getElementById('exitPrice').value) || 0;
                const sl = parseFloat(document.getElementById('sl').value) || 0;
                const tp = parseFloat(document.getElementById('tp').value) || 0;
                const size = parseFloat(document.getElementById('size').value) || 1;
                const commission = parseFloat(document.getElementById('commission').value) || 0;
                const comments = document.getElementById('comments').value;
                
                // Calcular PnL y PnL(R) usando la funci√≥n corregida
                const pnl = calculatePnl(entryPrice, exitPrice, size, direction, commission, instrument);
                const pnlR = calculatePnlR(entryPrice, exitPrice, sl, direction);
                
                // Crear objeto trade con el nuevo schema
                const trade = {
                    id: generateId(),
                    entryDate: entryDate,
                    exitDate: exitDate,
                    instrument: instrument.toUpperCase(),
                    strategy: strategy || '',
                    timeframe: timeframe || '',
                    direction: direction,
                    entryPrice: entryPrice,
                    exitPrice: exitPrice,
                    sl: sl,
                    tp: tp,
                    size: size,
                    commission: commission,
                    pnl: pnl,
                    pnlR: pnlR,
                    comments: comments || '',
                    _version: TRADE_SCHEMA.version,
                    _created: new Date().toISOString(),
                    _modified: new Date().toISOString()
                };
                
                // Validar trade antes de agregar
                const validation = validateTradeSchema(trade);
                if (!validation.valid) {
                    showNotification(`Datos inv√°lidos: ${validation.error}`, 'error');
                    return;
                }
                
                // Agregar trade al array
                trades.push(trade);
                
                // Crear backup antes de guardar
                createBackup('pre_add_trade');
                
                // Marcar cambios no guardados
                markUnsavedChanges();
                
                // Guardar y recargar
                if (saveTrades()) {
                    logAction('TRADE_ADDED', trade.id, {
                        instrument: trade.instrument,
                        pnl: trade.pnl,
                        direction: trade.direction
                    });
                    
                    safeLoadTrades();
                    resetForm();
                    showNotification('Trade agregado exitosamente', 'success');
                } else {
                    // Si hay error al guardar, revertir
                    trades.pop();
                    showNotification('Error guardando el trade. Intenta nuevamente.', 'error');
                }
                
            } catch (e) {
                console.error('Error adding trade:', e);
                showNotification('Error agregando trade. Verifica que todos los campos sean v√°lidos.', 'error');
                logAction('TRADE_ADD_ERROR', null, { error: e.message });
            }
        }

        function updateTrade() {
            if (isSafeMode) {
                showNotification('Modo seguro: No se pueden actualizar trades', 'warning');
                return;
            }
            
            if (!currentEditId || !validateForm()) return;
            
            try {
                const index = trades.findIndex(t => t.id === currentEditId);
                if (index === -1) {
                    showNotification('Trade no encontrado', 'error');
                    return;
                }
                
                // Crear backup antes de modificar
                createBackup('pre_update_trade');
                
                const updatedTrade = sanitizeTrade({
                    ...trades[index],
                    entryDate: formatDateISO(document.getElementById('entryDate').value),
                    exitDate: formatDateISO(document.getElementById('exitDate').value),
                    instrument: document.getElementById('instrument').value,
                    strategy: document.getElementById('strategy').value,
                    timeframe: document.getElementById('timeframe').value,
                    direction: document.getElementById('direction').value,
                    entryPrice: document.getElementById('entryPrice').value,
                    exitPrice: document.getElementById('exitPrice').value,
                    sl: document.getElementById('sl').value,
                    tp: document.getElementById('tp').value,
                    size: document.getElementById('size').value,
                    commission: document.getElementById('commission').value,
                    comments: document.getElementById('comments').value
                });
                
                // Recalcular PnL usando la funci√≥n corregida
                updatedTrade.pnl = calculatePnl(
                    updatedTrade.entryPrice, 
                    updatedTrade.exitPrice, 
                    updatedTrade.size, 
                    updatedTrade.direction, 
                    updatedTrade.commission,
                    updatedTrade.instrument
                );
                
                updatedTrade.pnlR = calculatePnlR(
                    updatedTrade.entryPrice, 
                    updatedTrade.exitPrice, 
                    updatedTrade.sl, 
                    updatedTrade.direction
                );
                
                trades[index] = updatedTrade;
                markUnsavedChanges();
                saveTrades();
                safeLoadTrades();
                resetForm();
                
                logAction('TRADE_UPDATED', updatedTrade.id, {
                    instrument: updatedTrade.instrument,
                    pnl: updatedTrade.pnl,
                    direction: updatedTrade.direction
                });
                
                showNotification('Trade actualizado exitosamente', 'success');
                
            } catch (e) {
                console.error('Error updating trade:', e);
                showNotification('Error actualizando trade', 'error');
                logAction('TRADE_UPDATE_ERROR', currentEditId, { error: e.message });
            }
        }

        function editTrade(tradeId) {
            const trade = trades.find(t => t.id === tradeId);
            if (!trade) {
                showNotification('Trade no encontrado', 'error');
                return;
            }
            
            currentEditId = tradeId;
            
            // Rellenar formulario con datos del trade
            document.getElementById('entryDate').value = formatDateForInput(trade.entryDate);
            document.getElementById('exitDate').value = formatDateForInput(trade.exitDate);
            document.getElementById('instrument').value = trade.instrument || '';
            document.getElementById('strategy').value = trade.strategy || '';
            document.getElementById('timeframe').value = trade.timeframe || '';
            document.getElementById('direction').value = trade.direction || '';
            document.getElementById('entryPrice').value = trade.entryPrice || '';
            document.getElementById('exitPrice').value = trade.exitPrice || '';
            document.getElementById('sl').value = trade.sl || '';
            document.getElementById('tp').value = trade.tp || '';
            document.getElementById('size').value = trade.size || 1;
            document.getElementById('commission').value = trade.commission || 0;
            document.getElementById('pnl').value = trade.pnl || 0;
            document.getElementById('pnlR').value = trade.pnlR || 0;
            document.getElementById('comments').value = trade.comments || '';
            
            // Cambiar modo del formulario
            document.getElementById('formModeIndicator').textContent = 'Modo: Edici√≥n';
            document.getElementById('addTradeBtn').style.display = 'none';
            document.getElementById('updateTradeBtn').style.display = 'flex';
            document.getElementById('cancelEditBtn').style.display = 'flex';
        }

        function deleteTrade(tradeId) {
            if (isSafeMode) {
                showNotification('Modo seguro: No se pueden eliminar trades', 'warning');
                return;
            }
            
            if (!confirm('¬øEst√°s seguro de eliminar este trade?')) return;
            
            try {
                const index = trades.findIndex(t => t.id === tradeId);
                if (index === -1) {
                    showNotification('Trade no encontrado', 'error');
                    return;
                }
                
                const deletedTrade = trades[index];
                
                // Crear backup antes de eliminar
                createBackup('pre_delete_trade');
                
                trades.splice(index, 1);
                selectedTrades.delete(tradeId);
                
                markUnsavedChanges();
                saveTrades();
                safeLoadTrades();
                
                logAction('TRADE_DELETED', tradeId, {
                    instrument: deletedTrade.instrument,
                    pnl: deletedTrade.pnl
                });
                
                showNotification('Trade eliminado exitosamente', 'success');
                
            } catch (e) {
                console.error('Error deleting trade:', e);
                showNotification('Error eliminando trade', 'error');
            }
        }

        function duplicateTrade(tradeId) {
            if (isSafeMode) {
                showNotification('Modo seguro: No se pueden duplicar trades', 'warning');
                return;
            }
            
            try {
                const originalTrade = trades.find(t => t.id === tradeId);
                if (!originalTrade) {
                    showNotification('Trade no encontrado', 'error');
                    return;
                }
                
                // Crear copia con nuevo ID
                const duplicatedTrade = {
                    ...JSON.parse(JSON.stringify(originalTrade)),
                    id: generateId(),
                    _created: new Date().toISOString(),
                    _modified: new Date().toISOString(),
                    _duplicatedFrom: originalTrade.id
                };
                
                trades.push(duplicatedTrade);
                markUnsavedChanges();
                saveTrades();
                safeLoadTrades();
                
                logAction('TRADE_DUPLICATED', tradeId, {
                    newTradeId: duplicatedTrade.id,
                    instrument: duplicatedTrade.instrument
                });
                
                showNotification('Trade duplicado exitosamente', 'success');
                
            } catch (e) {
                console.error('Error duplicating trade:', e);
                showNotification('Error duplicando trade', 'error');
            }
        }

        function resetForm() {
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            document.getElementById('entryDate').value = formatDateForInput(oneHourAgo);
            document.getElementById('exitDate').value = formatDateForInput(now);
            document.getElementById('instrument').value = '';
            document.getElementById('strategy').value = '';
            document.getElementById('timeframe').value = '';
            document.getElementById('direction').value = '';
            document.getElementById('entryPrice').value = '';
            document.getElementById('exitPrice').value = '';
            document.getElementById('sl').value = '';
            document.getElementById('tp').value = '';
            document.getElementById('size').value = '1.00';
            document.getElementById('commission').value = '0.00';
            document.getElementById('pnl').value = '';
            document.getElementById('pnlR').value = '';
            document.getElementById('comments').value = '';
            
            // Resetear modo de edici√≥n
            currentEditId = null;
            document.getElementById('formModeIndicator').textContent = 'Modo: Creaci√≥n';
            document.getElementById('addTradeBtn').style.display = 'flex';
            document.getElementById('updateTradeBtn').style.display = 'none';
            document.getElementById('cancelEditBtn').style.display = 'none';
        }

        // ===== PAGINACI√ìN CORREGIDA =====
        function updatePaginationControls(totalPages) {
            const paginationContainer = document.getElementById('paginationControls');
            
            if (totalPages <= 1) {
                paginationContainer.innerHTML = '';
                return;
            }
            
            let html = '';
            
            // Bot√≥n anterior
            html += `
                <button class="pagination-btn" ${currentPage <= 1 ? 'disabled' : ''} 
                        data-page="${currentPage - 1}" title="P√°gina anterior">
                    ‚óÄ
                </button>
            `;
            
            // P√°ginas
            for (let i = 1; i <= totalPages; i++) {
                if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) {
                    html += `
                        <button class="pagination-btn ${i === currentPage ? 'active' : ''}" 
                                data-page="${i}">
                            ${i}
                        </button>
                    `;
                } else if (i === currentPage - 3 || i === currentPage + 3) {
                    html += `<span style="color: var(--muted); padding: 5px;">...</span>`;
                }
            }
            
            // Bot√≥n siguiente
            html += `
                <button class="pagination-btn" ${currentPage >= totalPages ? 'disabled' : ''} 
                        data-page="${currentPage + 1}" title="P√°gina siguiente">
                    ‚ñ∂
                </button>
            `;
            
            paginationContainer.innerHTML = html;
            
            // Agregar event listeners
            paginationContainer.querySelectorAll('.pagination-btn[data-page]').forEach(btn => {
                btn.addEventListener('click', function() {
                    currentPage = parseInt(this.dataset.page);
                    console.log('Cambiando a p√°gina:', currentPage);
                    safeLoadTrades();
                });
            });
        }

        // ===== FUNCIONES A√ëADIR AQU√ç FALTANTES =====
        function repairSelectedInvalidTrades() {
            if (selectedInvalidTrades.size === 0) {
                showNotification('No hay trades seleccionados para reparar', 'warning');
                return;
            }
            
            if (!confirm(`¬øReparar ${selectedInvalidTrades.size} trades seleccionados autom√°ticamente?`)) {
                return;
            }
            
            createBackup('pre_bulk_repair_invalid');
            
            let repairedCount = 0;
            let errorCount = 0;
            
            selectedInvalidTrades.forEach(tradeId => {
                const invalid = invalidTrades.find(inv => inv.trade.id === tradeId);
                if (invalid) {
                    try {
                        repairSingleTrade(invalid.index);
                        repairedCount++;
                    } catch (e) {
                        errorCount++;
                        console.error(`Error reparando trade ${tradeId}:`, e);
                    }
                }
            });
            
            selectedInvalidTrades.clear();
            showNotification(`${repairedCount} trades reparados${errorCount > 0 ? `, ${errorCount} errores` : ''}`, 
                           errorCount > 0 ? 'warning' : 'success');
        }

        function deleteSelectedInvalidTrades() {
            if (selectedInvalidTrades.size === 0) {
                showNotification('No hay trades seleccionados para eliminar', 'warning');
                return;
            }
            
            if (!confirm(`¬øEliminar permanentemente ${selectedInvalidTrades.size} trades seleccionados?`)) {
                return;
            }
            
            createBackup('pre_bulk_delete_invalid');
            
            let deletedCount = 0;
            
            selectedInvalidTrades.forEach(tradeId => {
                const index = trades.findIndex(t => t.id === tradeId);
                if (index !== -1) {
                    trades.splice(index, 1);
                    deletedCount++;
                }
            });
            
            selectedInvalidTrades.clear();
            markUnsavedChanges();
            saveTrades();
            safeLoadTrades();
            
            showNotification(`${deletedCount} trades eliminados permanentemente`, 'success');
        }

        function showRecoveryModal(reason) {
            const modal = document.getElementById('recoveryModal');
            const message = modal.querySelector('p:nth-of-type(1)');
            if (message) {
                message.textContent = `Se detectaron datos corruptos: ${reason}`;
            }
            modal.classList.remove('hidden');
        }

        function showBackupManager() {
            const modal = document.getElementById('backupModal');
            const backupList = document.getElementById('backupList');
            const backupCount = document.getElementById('backupCount');
            
            const backups = getAvailableBackups();
            backupCount.textContent = backups.length;
            
            if (backups.length === 0) {
                backupList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--muted);">
                        No hay backups disponibles
                    </div>
                `;
            } else {
                let html = '';
                backups.forEach(backup => {
                    const date = new Date(backup.timestamp);
                    const formattedDate = date.toLocaleString('es-ES', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    html += `
                        <div class="backup-item">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: var(--neon-cyan);">
                                    ${formattedDate}
                                </div>
                                <div style="font-size: 11px; color: var(--muted);">
                                    ${backup.reason} ‚Ä¢ ${backup.tradeCount} trades ‚Ä¢ Win Rate: ${backup.winRate}
                                </div>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 11px;" 
                                        data-backup-id="${backup.id}" data-action="restore">
                                    ‚Ü©Ô∏è Restaurar
                                </button>
                                <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;"
                                        data-backup-id="${backup.id}" data-action="delete">
                                    üóëÔ∏è Eliminar
                                </button>
                            </div>
                        </div>
                    `;
                });
                backupList.innerHTML = html;
            }
            
            modal.classList.remove('hidden');
        }

        function setupRealTimeValidation() {
            // Funci√≥n placeholder si no existe
            // Se puede implementar validaci√≥n en tiempo real aqu√≠
        }

        // ===== INICIALIZACI√ìN DE LA APLICACI√ìN =====
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Trading Suite - Programa 1 v3.2 iniciando...');
            
            // Verificar compatibilidad del navegador
            if (!window.localStorage) {
                alert('‚ö†Ô∏è Tu navegador no soporta localStorage. Algunas funciones no estar√°n disponibles.');
                isSafeMode = true;
            }
            
            // Verificar salud de los datos
            const health = checkDataHealth();
            
            if (!health.healthy) {
                console.warn('Datos corruptos detectados:', health.reason);
                showRecoveryModal(health.reason);
                isSafeMode = true;
            } else {
                loadInitialData();
            }
            
            // Configurar todas las funcionalidades
            setupEventListeners();
            setupAutoCalculations();
            setupAutocomplete();
            setupRealTimeValidation();
            setupBreakevenValidation(); // Nueva funci√≥n para permitir breakeven
            startAutoSave();
            
            // Configurar ordenamiento inicial
            const initialSortHeader = document.querySelector('#tradesTable th[data-sort="entryDate"]');
            if (initialSortHeader) {
                initialSortHeader.classList.add('sort-desc');
            }
            
            // Crear backup inicial
            setTimeout(() => {
                if (trades.length > 0) {
                    createBackup('initial_load');
                }
            }, 2000);
            
            console.log('‚úÖ Trading Suite v3.2 - Listo con mejoras implementadas');
            console.log('‚ú® Mejoras implementadas:');
            console.log('   1. ‚úÖ PERMITIDO: Trades en breakeven (precios iguales)');
            console.log('   2. ‚úÖ Panel de trades problem√°ticos con pesta√±as: Todos/Duplicados/Inv√°lidos/Breakeven');
            console.log('   3. ‚úÖ Funci√≥n "Restaurar" que mueve trades a lista principal (como papelera de reciclaje)');
            console.log('   4. ‚úÖ Sistema anti-acumulaci√≥n: IDs de sesi√≥n para evitar duplicados en importaciones');
            console.log('   5. ‚úÖ Mejor detecci√≥n de duplicados reales (no falsos positivos)');
            console.log('   6. ‚úÖ Bot√≥n "Marcar todos como v√°lidos" para ignorar advertencias');
            console.log('   7. ‚úÖ Animaciones y feedback visual mejorado');
        });

        // ===== MANEJO DE CIERRE =====
        window.addEventListener('beforeunload', function(e) {
            if (hasUnsavedChanges && !isSafeMode) {
                e.preventDefault();
                e.returnValue = 'Tienes cambios sin guardar. ¬øEst√°s seguro de querer salir?';
                return e.returnValue;
            }
        });
    </script>
</body>
</html>
